
<p>
<a href="https://github.com/gilligan/snesdev/blob/master/docs/65816.txt" class="urlextern" title="https://github.com/gilligan/snesdev/blob/master/docs/65816.txt" rel="ugc nofollow">https://github.com/gilligan/snesdev/blob/master/docs/65816.txt</a>
<a href="http://datasheets.chipdb.org/Western%20Design/w65c816s.pdf" class="urlextern" title="http://datasheets.chipdb.org/Western%20Design/w65c816s.pdf" rel="ugc nofollow">http://datasheets.chipdb.org/Western%20Design/w65c816s.pdf</a>
<a href="/lib/exe/fetch.php?media=w65c816s.pdf" class="media mediafile mf_pdf" title="w65c816s.pdf (1.1 MB)">w65c816s.pdf</a>
</p>

<p>
Das SNES hat einen abgewandelten Prozessor zum Western Digital W65C816S.
Dieser arbeitet mit 92 Operationen, 24 Addressmodes, 6 16-BIT Register(A, PC, X, Y, D, S) und 3 8-BIT Registern (P, PBR, DBR)
</p>

<h1 class="sectionedit1" id="allgemein">Allgemein</h1>
<div class="level1">

<p>
Der SNES-Prozessor arbeitet Little Endian (LE).
Das heißt Words (Java Shorts) werden in der Reihenfolge Low-Byte High-Byte gespeichert, Long in der Reihenfolge Low-Byte High-Byte Long-Byte.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Allgemein&quot;,&quot;hid&quot;:&quot;allgemein&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:1,&quot;range&quot;:&quot;353-569&quot;} -->
<h1 class="sectionedit2" id="register">Register</h1>
<div class="level1">

<p>
Um arbeiten zu können hat der Prozessor eine Anzahl an Register, welcher (mehr oder minder) beliebig genutzt werden können.
Ein Register ist immer 8- oder 16-BIT groß - ein 16-BIT Register kann aber auch als 8-BIT Register verwendet werden.
wird ein &#039;volles&#039; Register ($FF bei 8-BIT, $FFFF bei 16-BIT) weiter erhöht oder ein &#039;leeres&#039; Register ($0000) gesenkt so gibt es einen Überlauf ($FF → $00).
<strong>Achtung</strong> wird ein 16-BIT Register als 8-BIT verwendet, so passirt der Überlauf auch auf 8-BIT.
Sprich wird z. B. der Accumulator als 8-BIT genutzt und hat den Wert $12FF wird sein nächster Wert $1200 sein und nicht $1300.
</p>
<div class="table sectionedit3"><table class="inline">
	<thead>
	<tr class="row0">
		<th class="col0"> Register </th><th class="col1"> Größe </th><th class="col2"> Beschreibung </th>
	</tr>
	</thead>
	<tr class="row1">
		<td class="col0"> PC </td><td class="col1"> 16-BIT </td><td class="col2"> <strong>P</strong>rogram <strong>C</strong>ounter - die 16-BIT Adresse innerhalb der aktuellen Bank (PBR) welche aktuel selektiert ist. Diese Adresse wird genutzt, um den nächsten Befehl zu holen oder um Addressmodi aufzulösen </td>
	</tr>
	<tr class="row2">
		<td class="col0"> P </td><td class="col1"> 8-BIT </td><td class="col2"> Statusregister - hält 8 Status (1 je Bit) als Folge der vorangegangenen Operationen </td>
	</tr>
	<tr class="row3">
		<td class="col0"> PBR </td><td class="col1"> 8-BIT </td><td class="col2"> <strong>P</strong>rogram <strong>B</strong>ank <strong>R</strong>egister - enthält die Bank für den aktuellen/nächsten Befehl (PC). Wird ebenfalls für einige Addressmodi verwendet </td>
	</tr>
	<tr class="row4">
		<td class="col0"> DBR </td><td class="col1"> 8-BIT </td><td class="col2"> <strong>D</strong>ata <strong>B</strong>ank <strong>R</strong>egister - wie PBR, wird für einige Addressmodi verwendet </td>
	</tr>
	<tr class="row5">
		<td class="col0"> A </td><td class="col1"> 8/16-BIT </td><td class="col2"> <strong>A</strong>ccumulator - Der accumulator wird für so ziemlich alle internen REchnungen verwendet, er ist das &#039;Hilfsregister&#039;. Er hält <strong>immer</strong> 16-BIT, je nach Prozessormodus und P wird er jedoch u. U. als 8-BIT Register verwendet. In diesem Fall bleibt das höhere Byte erhalten und kann mit einer speziellen Operation als zusätzlicher Speicher verwendet werden. </td>
	</tr>
	<tr class="row6">
		<td class="col0"> X/Y </td><td class="col1"> 8/16-BIT </td><td class="col2"> das X und das Y-Register ist jeweils ein weiteres Hilfsregister, wie der Accumulator um Aktionen auszuführen. Je nach P wird es als 8 oder 16-BIT Register verwendet. Wenn es als 8-BIT Register genutzt wird ist das höhere (ungenutzte) Byte immer $00 </td>
	</tr>
	<tr class="row7">
		<td class="col0"> D </td><td class="col1"> 16-BIT </td><td class="col2"> <strong>D</strong>irect Register - wird für alle Direct-Addressmodi verwendet. Das Direct Register wird immer dann verwendet, wenn der Addressmodus nur 1 Byte erhält und soll die Page darstellen. Insofern hat diesen Register in der Regel die Form $xx00. Sollte das untere Byte einen anderen Wert haben führt dies in der Regel zu einem zusätzlich benötigten Cycle </td>
	</tr>
	<tr class="row8">
		<td class="col0"> S </td><td class="col1"> 8/16-Bit </td><td class="col2"> <strong>S</strong>tack Register - verwaltet die nächste zu verwendende Addresse auf dem Stack. Je nach Prozessormodus wird dieser Pointer asl 8- oder 16-BIT verwendet. Im 8-BIT modus ist dabei das höhere Byte immer $01 </td>
	</tr>
</table></div>
<!-- EDIT{&quot;target&quot;:&quot;table&quot;,&quot;name&quot;:&quot;&quot;,&quot;hid&quot;:&quot;table&quot;,&quot;secid&quot;:3,&quot;range&quot;:&quot;1226-3097&quot;} -->
</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Register&quot;,&quot;hid&quot;:&quot;register&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:2,&quot;range&quot;:&quot;570-3098&quot;} -->
<h2 class="sectionedit4" id="program_counter_pc">Program Counter (PC)</h2>
<div class="level2">

<p>
Der Program Counter ist ein 16-BIT Register, das sehr eng mit dem PBR zusammenarbeiten.
Er zeigt auf die nächste auszuführende Instruktion innerhalb des PBR (PBR|PC bilden die effektive Addresse).
wann immer ein Wert mit Hilfe des PC gelesen wird, wird dieser um 1 erhöht.
Werden für den Addressmodus noch weitere Werte benötigt werden diese (soweit nicht anders beschrieben) mit Hilfe des PC geholt.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Program Counter (PC)&quot;,&quot;hid&quot;:&quot;program_counter_pc&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:4,&quot;range&quot;:&quot;3099-3539&quot;} -->
<h3 class="sectionedit5" id="direct_page_zero_page_d">Direct Page/Zero Page (D)</h3>
<div class="level3">

<p>
Die Zero Page aus dem originalen 6502 (NES) wurde im SNES Prozessor nach Direct Page umbenannt.
Immer wenn ein Addressmodus mit einem Byte gewählt wird bestimmt die Direct Page die Page-Adresse (mittleres Byte)
Die Direct Page ist 16-Bit groß und kann dementsprechend neben der Page auch einen Versatz für das Byte beinhalten, jedoch wird in dem Fall (Low-Byte != 0) ein Cycle mehr benötigt.
Im Emulation Mode ist die Adressierung in der Direct Page gefangen, sprich ein Rollover nach $FF beginnt wieder bei $00 der Direct Page (NES).
Im Native Mode hingegen geht ein Rollover in die nächste Page.
Beispiel:
</p>
<pre class="code">LDX #$2c
LDA ($E0,X)</pre>

<p>
In Emulation Mode ergibt dies die Adresse $0C, im Native Mode $10C
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Direct Page\/Zero Page (D)&quot;,&quot;hid&quot;:&quot;direct_page_zero_page_d&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:5,&quot;range&quot;:&quot;3540-4293&quot;} -->
<h3 class="sectionedit6" id="stack_pointer_s">Stack Pointer (S)</h3>
<div class="level3">

<p>
Der Stack Pointer ist 16-Bit groß und zeigt auf die nächste leere (zu nutzende) Speicheradresse für den Stack.
Im Emulation Mode wird das High-Byte (Page) immer auf $01 gezwungen (NES).
Der Stack Pointer wird entsprechend im Emulation Mode als 8-Bit Register gehandelt.
In der Regel ist/wird der Stack Pointer zum Programmstart auf $01FF initialisiert.
Wird ein Element auf dem Stack abgelegt, so wird der Wert auf die Adresse des Stack Pointers gelegt und dieser anschließend um 1 gesenkt.
Der Pull geschieht entsprechend umgekehrt, erst wird der Pointer incrementiert und anschließend wird der Wert gelesen.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Stack Pointer (S)&quot;,&quot;hid&quot;:&quot;stack_pointer_s&quot;,&quot;codeblockOffset&quot;:1,&quot;secid&quot;:6,&quot;range&quot;:&quot;4294-4938&quot;} -->
<h3 class="sectionedit7" id="program_bank_register_pbr">Program Bank Register (PBR)</h3>
<div class="level3">

<p>
Der PBR ist ein 8-Bit Register welches die Bank zum PC beschreiben.
Der PBR wird immer verwendet, wenn das nächste Byte im Ablauf geholt wird, entweder die Instruktion, oder direkt darauf folgenden Bytes für den Addresmodus.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Program Bank Register (PBR)&quot;,&quot;hid&quot;:&quot;program_bank_register_pbr&quot;,&quot;codeblockOffset&quot;:1,&quot;secid&quot;:7,&quot;range&quot;:&quot;4939-5205&quot;} -->
<h3 class="sectionedit8" id="data_bank_register_dbr">Data Bank register (DBR)</h3>
<div class="level3">

<p>
Der DBR ist ein 8-Bit Register welches die Bank für bestimmte Addressmodi hält.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Data Bank register (DBR)&quot;,&quot;hid&quot;:&quot;data_bank_register_dbr&quot;,&quot;codeblockOffset&quot;:1,&quot;secid&quot;:8,&quot;range&quot;:&quot;5206-5324&quot;} -->
<h3 class="sectionedit9" id="status_register_p">Status Register (P)</h3>
<div class="level3">

<p>
das StatusRegister besteht aus den Flags NVMXDIZC.
Im Emulation Mode ist es NV1BDIZC.
Das M- und X-Flag dient dazu Accumulator, X und Y zwischen 8 und 16-Bit zu wechseln.
Dementsprechend werden diese im Emulation Mode anders verwendet:
Die Flags:
</p>
<ul>
<li class="level1"><div class="li"> N - Negative steht für einen negativen Wert.</div>
</li>
<li class="level1"><div class="li"> V - Overflow zeigt an, wenn für eine Aktion ein zusätzliches Byte benötigt worden wäre</div>
</li>
<li class="level1"><div class="li"> M - Memory/Accumulator schaltet den Accumulator auf 16-Bit wenn auf 0 gesetzt. Im Emulation Mode ist dieser auf 1 gezwungen</div>
</li>
<li class="level1"><div class="li"> X - Index schaltet X und Y auf 16-Bit wenn auf 0 gesetzt. Wird im Emulation Mode auf 1 gesetzt und als B gehandelt.</div>
</li>
<li class="level1"><div class="li"> B - Break beschreibt das X-Flag im Emulation mode. Es eig. immer 1 im Register und wird bei einem Interrupt als 0 gepusht, wenn der Interrupt nicht durch ein BRK ausgelöst wurde.</div>
</li>
<li class="level1"><div class="li"> D - decimal, wenn auf 1, dann werden ADC und SBC im decimal mode berechnet ($20 - $04 = $16)</div>
</li>
<li class="level1"><div class="li"> I - IRQ-Disable wenn auf true, werden keine Interrupts ausgeführt außer NMI</div>
</li>
<li class="level1"><div class="li"> Z - Zero, wird bei null gestzt, zeigt ebenfalls gleichheit an. beq - branch if equal springt bei Z = 1</div>
</li>
<li class="level1"><div class="li"> C - Carry wird als zusätzliches Bit für einige Operationen verwendet. C und XCE sind der einzige Weg des Prozessormodus anzupassen.</div>
</li>
</ul>

<p>
<a href="/lib/exe/fetch.php?media=statusregister.png" class="media" title="statusregister.png"><img src="/lib/exe/fetch.php?w=800&amp;tok=4106f1&amp;media=statusregister.png" class="media" alt="" width="800" /></a>
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Status Register (P)&quot;,&quot;hid&quot;:&quot;status_register_p&quot;,&quot;codeblockOffset&quot;:1,&quot;secid&quot;:9,&quot;range&quot;:&quot;5325-6641&quot;} -->
<h3 class="sectionedit10" id="accumulator_a">Accumulator (A)</h3>
<div class="level3">

<p>
Der Accumulator ist einer der Hauptregister mit denen gearbeitet wird.
Er wird hauptsächlich verwendet, wenn man Daten lesen schreiben und verrechnen möchte.
Er ist 16-Bit groß und kann im 8-Bit Modus verwendet werden (je nach P).
Im Gegensatz zu allen anderen “variablen” Register behält der Accumulator den Wert seines High-Byte bei.
So kann das High-Byte im 8-Bit modus als zusätzlicher Speicher verwendet werden.
Mit Hilfe der XBA instruktion kann so der Wert des High und des Low-Bytes getauscht werden.
</p>

<p>
je nach Situation hat der Accumulator drei Namen, A, B und C.
Mit C ist der Accumulator immer als 16-Bit Register bezeichnet.
Dementsprechend tauscht die Instruktion TCS immer die kompletten 16-Bit von A (C) nach S.
B beschreibt immer das High-Byte des Accumulators.
A beschreibt je nach Kontext entweder den Accumulator allgemein oder nur das LOW-Byte (z. B. in XBA - exchange B and A).
Einige Assembler nehmen diese Trennund nicht 100% und erlauben so auch z. B. die Operation TAS als Synonym für TCS.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Accumulator (A)&quot;,&quot;hid&quot;:&quot;accumulator_a&quot;,&quot;codeblockOffset&quot;:1,&quot;secid&quot;:10,&quot;range&quot;:&quot;6642-7689&quot;} -->
<h3 class="sectionedit11" id="x_y_register_x_y">X/Y Register (X/Y)</h3>
<div class="level3">

<p>
X und Y sind 2 Hilfsregister, welche zusammen mit dem Accumulator verwendet werden.
Sie sind 16-BIT groß und können je nach P auch als 8-Bit verwendet werden.
Werden Sie als 8-Bit verwendet ist das High-Byte immer 0
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;X\/Y Register (X\/Y)&quot;,&quot;hid&quot;:&quot;x_y_register_x_y&quot;,&quot;codeblockOffset&quot;:1,&quot;secid&quot;:11,&quot;range&quot;:&quot;7690-7938&quot;} -->
<h2 class="sectionedit12" id="prozessormodi">Prozessormodi</h2>
<div class="level2">

<p>
Der Prozesser hat 2 Modi, Emulation und Native.
Bei Start des Prozessors ist dieser immer im Emulation Mode und der PC zeigt auf den Reset-Vector.
Der Modus wird über die XCE-Instruktion gesetzt, wobei ein gesetztes C-Flag den Native-Mode aktiviert.
Im Emulation Mode ist der Prozessor kompatibel zum NES 6502, dementsprechend sind alle variablen Register im 8-BIT Modus.
Im Native-Mode können A, X, und Y je nach P als 16-Bit verwendet werden - S ist automatisch 16-BIT.
Die Interrupt-Handler sind unterschiedlich je nach Modus:
</p>
<div class="table sectionedit13"><table class="inline">
	<thead>
	<tr class="row0">
		<th class="col0"> Adresse Emulation </th><th class="col1"> Vector Emulation </th><th class="col2"> Adresse Native </th><th class="col3"> Vector Native </th>
	</tr>
	</thead>
	<tr class="row1">
		<td class="col0"> $FFF4-5 </td><td class="col1 leftalign"> COP     </td><td class="col2"> $FFE4-5 </td><td class="col3"> COP </td>
	</tr>
	<tr class="row2">
		<td class="col0"> $FFF6-7 </td><td class="col1 leftalign">         </td><td class="col2"> $FFE6-7 </td><td class="col3"> BRK </td>
	</tr>
	<tr class="row3">
		<td class="col0"> $FFF8-9 </td><td class="col1 leftalign"> ABORT   </td><td class="col2"> $FFE8-9 </td><td class="col3"> ABORT </td>
	</tr>
	<tr class="row4">
		<td class="col0"> $FFFA-B </td><td class="col1 leftalign"> NMI     </td><td class="col2"> $FFEA-B </td><td class="col3"> NMI </td>
	</tr>
	<tr class="row5">
		<td class="col0"> $FFFC-D </td><td class="col1 leftalign"> RESET   </td><td class="col2"> $FFEC-D </td><td class="col3"> RESET (ungenutzt) </td>
	</tr>
	<tr class="row6">
		<td class="col0"> $FFFE-F </td><td class="col1"> IRQ/BRK </td><td class="col2"> $FFEE-F </td><td class="col3"> IRQ </td>
	</tr>
</table></div>
<!-- EDIT{&quot;target&quot;:&quot;table&quot;,&quot;name&quot;:&quot;&quot;,&quot;hid&quot;:&quot;table1&quot;,&quot;secid&quot;:13,&quot;range&quot;:&quot;8498-8815&quot;} -->
<p>
Da der Prozessor beim Startup immer im Emulation-Mode ist wird der Reset-Vector vom Native-Mode nicht genutzt.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Prozessormodi&quot;,&quot;hid&quot;:&quot;prozessormodi&quot;,&quot;codeblockOffset&quot;:1,&quot;secid&quot;:12,&quot;range&quot;:&quot;7939-8928&quot;} -->
<h2 class="sectionedit14" id="stack_operationen">Stack Operationen</h2>
<div class="level2">

<p>
Auf den Stack können einzelne Bytes oder Word gepusht werden.
Wenn immer ein Wert auf den Stack gepusht wird, wird der Stackpointer um 1 reduziert.
Wird ein Word gepusht, wird zuerst das High-Byte und anschließend das Low-Byte gepusht, sodass das Word im Speicher wieder in Little-Endian steht.
Wird ein Byte gepusht, wird zuerst der Wert im gespeichert und anschließend der Pointer dekrementiert.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Stack Operationen&quot;,&quot;hid&quot;:&quot;stack_operationen&quot;,&quot;codeblockOffset&quot;:1,&quot;secid&quot;:14,&quot;range&quot;:&quot;8929-9361&quot;} -->
<h2 class="sectionedit15" id="interrupts">Interrupts</h2>
<div class="level2">

<p>
Wenn ein Interrupt ausgelöst wird werden alle nötigen Register auf den Stack gepusht und je nach Modus zum Interrupthandler gesprungen.
Zusätzlich wird PBR auf 0 gesetzt, sodass sich ein Interrupthandler immer in der Bank 0 befindet.
Außerdem wird das IRQDisable-Flag auf 1 gesetzt (D auf 0), um weitere interrupts zu vermeiden.
Mithilfe von rti (0x40) wird zum vorherigen Zustand zurückgesprungen.
Folgende Werte werden in dieser Reihenfolge gepusht und bei rti umgedreht gepullt:
</p>
<ul>
<li class="level1"><div class="li"> PBR (Native Mode)</div>
</li>
<li class="level1"><div class="li"> PC (Short)</div>
</li>
<li class="level1"><div class="li"> P</div>
</li>
</ul>

<p>
Ein Interrupt findet nicht statt, wenn das IRQ-Disable flag true ist.
Ausnahme hiervon ist der NMI, welcher nicht über P verhindert werden kann.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Interrupts&quot;,&quot;hid&quot;:&quot;interrupts&quot;,&quot;codeblockOffset&quot;:1,&quot;secid&quot;:15,&quot;range&quot;:&quot;9362-10063&quot;} -->
<h1 class="sectionedit16" id="operationen">Operationen</h1>
<div class="level1">

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Operationen&quot;,&quot;hid&quot;:&quot;operationen&quot;,&quot;codeblockOffset&quot;:1,&quot;secid&quot;:16,&quot;range&quot;:&quot;10064-10090&quot;} -->
<h1 class="sectionedit17" id="addressmodes">Addressmodes</h1>
<div class="level1">

<p>
Der AddressMode zeigt an, welche Daten eine Operation nutzt, bzw. wie die Daten ermittelt werden.
Es gibt für das SNES folgende Addressmodes:
</p>
<div class="table sectionedit18"><table class="inline">
	<thead>
	<tr class="row0">
		<th class="col0"> Addressmode </th><th class="col1"> Schema </th><th class="col2"> Bytes </th><th class="col3"> Bank </th><th class="col4"> Operationen </th>
	</tr>
	</thead>
	<tr class="row1">
		<td class="col0"> absolute </td><td class="col1"> a </td><td class="col2"> 2 </td><td class="col3"> DBR </td><td class="col4 leftalign"> ADC, AND, ASL, BIT, CMP, CPX, CPY, DEC, EOR, INC, JMP, JSR, LDA, LDX, LDY, LSR, ORA, ROL, ROR, SBC, STA, STX, STY, STZ, TRB, TSB  </td>
	</tr>
	<tr class="row2">
		<td class="col0"> absolute indexed indirect </td><td class="col1"> (a,x) </td><td class="col2"> 2 </td><td class="col3"> PBR </td><td class="col4 leftalign"> JMP, JSR  </td>
	</tr>
	<tr class="row3">
		<td class="col0"> absolute indexed with x </td><td class="col1"> a,x </td><td class="col2"> 2 </td><td class="col3"> DBR </td><td class="col4 leftalign"> ADC, AND, ASL, BIT, CMP, DEC, EOR, INC, LDA, LDY, LSR, ORA, ROL, ROR, SBC, STA, STZ  </td>
	</tr>
	<tr class="row4">
		<td class="col0"> absolute indexed with Y </td><td class="col1"> a,y </td><td class="col2"> 2 </td><td class="col3"> DBR </td><td class="col4 leftalign"> ADC, AND, CMP, EOR, LDA, LDX, ORA, SBC, STA  </td>
	</tr>
	<tr class="row5">
		<td class="col0"> absolute indirect/absolute indirect long </td><td class="col1"> (a)/(al) </td><td class="col2"> 2/3 </td><td class="col3"> 00/Param </td><td class="col4"> JML, JMP </td>
	</tr>
	<tr class="row6">
		<td class="col0"> absolute long indexed with x </td><td class="col1"> al,x </td><td class="col2"> 3 </td><td class="col3"> Caluculated </td><td class="col4"> ADC, AND, CMP, EOR, LDA, ORA, SBC, STA </td>
	</tr>
	<tr class="row7">
		<td class="col0"> absolute long </td><td class="col1"> al </td><td class="col2"> 3 </td><td class="col3"> Param </td><td class="col4"> ADC, AND, CMP, EOR, JMP, JSR, LDA, ORA, SBC, STA </td>
	</tr>
	<tr class="row8">
		<td class="col0"> Accumulator </td><td class="col1"> A </td><td class="col2"> 0 </td><td class="col3"> </td><td class="col4"> ASL, DEA, DEC, INA, INC, LSR, ROL, ROR </td>
	</tr>
	<tr class="row9">
		<td class="col0"> Block Move </td><td class="col1"> xyc </td><td class="col2"> 2 </td><td class="col3"> </td><td class="col4"> MVN, MVP </td>
	</tr>
	<tr class="row10">
		<td class="col0"> direct indexed indirect </td><td class="col1"> (d,x) </td><td class="col2"> 1 </td><td class="col3"> DBR </td><td class="col4 leftalign"> ADC, AND, CMP, EOR, LDA, ORA, SBC, STA  </td>
	</tr>
	<tr class="row11">
		<td class="col0"> direct indexed with X </td><td class="col1"> d,x </td><td class="col2"> 1 </td><td class="col3"> 00 </td><td class="col4"> ADC, AND, ASL, BIT, CMP, DEC, EOR, INC, LDA, LDY, LSR, ORA, ROL, ROR, SBC, STA, STY, STZ </td>
	</tr>
	<tr class="row12">
		<td class="col0"> direct indexed with Y </td><td class="col1"> d,y </td><td class="col2"> 1 </td><td class="col3"> 00 </td><td class="col4"> LDX, STX </td>
	</tr>
	<tr class="row13">
		<td class="col0"> direct indirect indexed </td><td class="col1"> (d),y </td><td class="col2"> 1 </td><td class="col3"> calculated </td><td class="col4"> ADC, AND, CMP, EOR, LDA, ORA, SBC, STA </td>
	</tr>
	<tr class="row14">
		<td class="col0"> direct indirect long indexed </td><td class="col1"> [d],y </td><td class="col2"> 1 </td><td class="col3"> calculated </td><td class="col4"> ADC, AND, CMP, EOR, LDA, ORA, SBC, STA </td>
	</tr>
	<tr class="row15">
		<td class="col0"> direct indirect long </td><td class="col1"> [d] </td><td class="col2"> 1 </td><td class="col3"> loaded </td><td class="col4"> ADC, AND, CMP, EOR, LDA, ORA, SBC, STA </td>
	</tr>
	<tr class="row16">
		<td class="col0"> direct indirect </td><td class="col1"> (d) </td><td class="col2"> 1 </td><td class="col3"> DBR </td><td class="col4"> ADC, AND, CMP, EOR, LDA, ORA, SBC, STA </td>
	</tr>
	<tr class="row17">
		<td class="col0"> direct </td><td class="col1"> d </td><td class="col2"> 1 </td><td class="col3"> 00 </td><td class="col4"> ADC, AND, ASL, BIT, CMP, CPX, CPY, DEC, EOR, INC, LDA, LDX, LDY, LSR, ORA, ROL, ROR, SBC, STA, STX, STY, STZ, TRB, TSB </td>
	</tr>
	<tr class="row18">
		<td class="col0"> immediate </td><td class="col1"> # </td><td class="col2"> 1/2 </td><td class="col3"> </td><td class="col4"> ADC, AND, BIT, CMP, CPX, CPY, EOR, LDA, LDX, LDY, ORA, REP, SBC, SEP </td>
	</tr>
	<tr class="row19">
		<td class="col0"> implied </td><td class="col1"> i </td><td class="col2"> 0 </td><td class="col3"> </td><td class="col4"> CLC, CLD, CLI, CLV, DEX, DEY, INX, INY, NOP, SEC, SED, SEI, STP, TAX, TAY, TCD, TCS, TDC, TSC, TSX, TXA, TXS, TXY, TYA, TYX, WAI, XBA, XCE </td>
	</tr>
	<tr class="row20">
		<td class="col0"> program counter relative long </td><td class="col1"> rl </td><td class="col2"> 2 </td><td class="col3"> PBR </td><td class="col4"> BRL </td>
	</tr>
	<tr class="row21">
		<td class="col0"> program counter relative </td><td class="col1"> r </td><td class="col2"> 1 </td><td class="col3"> PBR </td><td class="col4"> BCC, BCS, BEQ, BMI, BNE, BPL, BRA, BVC, BVS </td>
	</tr>
	<tr class="row22">
		<td class="col0"> Stack </td><td class="col1"> s </td><td class="col2"> 0 </td><td class="col3"> </td><td class="col4"> BRK, COP, PEA, PEI, PER, PHA, PHB, PHD, PHK, PHP, PHX, PHY, PLA, PLB, PLD, PLP, PLX, PLY, RTI, RTL, RTS </td>
	</tr>
	<tr class="row23">
		<td class="col0"> stack relative </td><td class="col1"> d,s </td><td class="col2"> 1 </td><td class="col3"> 00 </td><td class="col4"> ADC, AND, CMP, EOR, LDA, ORA, SBC, STA </td>
	</tr>
	<tr class="row24">
		<td class="col0"> stack relative indirect indexed </td><td class="col1"> (d,s),y </td><td class="col2"> 1 </td><td class="col3"> Calculated </td><td class="col4"> ADC, AND, CMP, EOR, LDA, ORA, SBC, STA </td>
	</tr>
</table></div>
<!-- EDIT{&quot;target&quot;:&quot;table&quot;,&quot;name&quot;:&quot;&quot;,&quot;hid&quot;:&quot;table2&quot;,&quot;secid&quot;:18,&quot;range&quot;:&quot;10262-12611&quot;} -->
<p>
Hierzu einige Regeln, welche man hieraus ableiten kann:
</p>
<ul>
<li class="level1"><div class="li"> a (für absolute) heißt das die kommenden Bytes direkt genommen und ausgewertet werden </div>
</li>
<li class="level1"><div class="li"> d (für direct) im Vergleich zu a heißt immer, dass nur 1 Byte gebraucht wird und ein Register als &#039;Page&#039; draufgerechnet wird. Dieses Register ist immer D ausßer bei (d,s),y wo es S ist.</div>
</li>
<li class="level1"><div class="li"> eine Klammerung steht immer für einen Indirect-Zugriff. Das heißt es wird mit den Bytes eine Adresse aufgelöst, deren Inhalt wird als weitere Addresse verwendet, um den endgültigen Wert zu bestimmen.</div>
</li>
<li class="level1"><div class="li"> Die eckigen Klammern [] wurden verwendet um bei direct zwischen der normalen () und der long [] Variante zu unterschieden. Hier hätte man auch alternative dl verwenden können anstelle einer neuen Klammerart</div>
</li>
<li class="level1"><div class="li"> Ein Komma , bedeutet immer, dass das Register nach dem Komma auf den WErt aufgerechnet wird.</div>
</li>
<li class="level1"><div class="li"> Die Darstellung zeigt den Ablauf der Auflösung z. B (a,x) heißt, es wird zuerst x aufgerechnet und dann die indirekte Auslösung, während (d),y umgekehrt arbeitet</div>
</li>
</ul>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Addressmodes&quot;,&quot;hid&quot;:&quot;addressmodes&quot;,&quot;codeblockOffset&quot;:1,&quot;secid&quot;:17,&quot;range&quot;:&quot;10091-13643&quot;} -->
<h2 class="sectionedit19" id="absolute_addresmodes">Absolute Addresmodes</h2>
<div class="level2">

<p>
Bei Absolute AddressModes werden immer 2 oder 3 Bytes gelesen und weiterverarbeitet.
Dies sind generell die am einfachsten zu verstehenden Modi.
Die Varianten mit 3 Bytes werden dabei in der Regel mit dem Kürzel Long gekennzeichnet.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Absolute Addresmodes&quot;,&quot;hid&quot;:&quot;absolute_addresmodes&quot;,&quot;codeblockOffset&quot;:1,&quot;secid&quot;:19,&quot;range&quot;:&quot;13644-13912&quot;} -->
<h3 class="sectionedit20" id="absolute_-_a">Absolute - a</h3>
<div class="level3">

<p>
Bei Absolute Addressing werden die kommenden 2 Bytes direkt als Addresse genommen.
Der DBR enthält dabei die Bank.
</p>

<p>
<a href="/lib/exe/fetch.php?media=addressmode_absolute.png" class="media" title="addressmode_absolute.png"><img src="/lib/exe/fetch.php?w=400&amp;tok=489bc5&amp;media=addressmode_absolute.png" class="mediacenter" alt="" width="400" /></a>
</p>

<p>
Verwendende Operationen: ADC, AND, ASL, BIT, CMP, CPX, CPY, DEC, EOR, INC, JMP, JSR, LDA, LDX, LDY, LSR, ORA, ROL, ROR, SBC, STA, STX, STY, STZ, TRB, TSB
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Absolute - a&quot;,&quot;hid&quot;:&quot;absolute_-_a&quot;,&quot;codeblockOffset&quot;:1,&quot;secid&quot;:20,&quot;range&quot;:&quot;13913-14254&quot;} -->
<h3 class="sectionedit21" id="absolute_indexed_indirect_-_a_x">Absolute indexed indirect - (a,x)</h3>
<div class="level3">

<p>
Bei der Absolute indexed Indirect Adressierung werden die kommenden 2 Bytes als Basis genommen.
Auf diese Adresse wird dann das X-Register aufgerechnet.
Die Bank ist der PBR.
</p>

<p>
<a href="/lib/exe/fetch.php?media=addressmode_absoluteindexedindirect.png" class="media" title="addressmode_absoluteindexedindirect.png"><img src="/lib/exe/fetch.php?w=400&amp;tok=230999&amp;media=addressmode_absoluteindexedindirect.png" class="mediacenter" alt="" width="400" /></a>
</p>

<p>
verwendende Operationen: JMP, JSR
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Absolute indexed indirect - (a,x)&quot;,&quot;hid&quot;:&quot;absolute_indexed_indirect_-_a_x&quot;,&quot;codeblockOffset&quot;:1,&quot;secid&quot;:21,&quot;range&quot;:&quot;14255-14571&quot;} -->
<h3 class="sectionedit22" id="absolute_indexed_with_x_-_a_x">Absolute Indexed with X - a,x</h3>
<div class="level3">

<p>
Bei Absolute Indexed with X-Addressing werden die kommenden 2 Byte als Basis genommen.
Auf diese wird das X-Register aufgerechnet.
Die Bank ist der DBR.
</p>

<p>
<a href="/lib/exe/fetch.php?media=addressmode_absoluteindexedwithx.png" class="media" title="addressmode_absoluteindexedwithx.png"><img src="/lib/exe/fetch.php?w=400&amp;tok=82329e&amp;media=addressmode_absoluteindexedwithx.png" class="mediacenter" alt="" width="400" /></a>
</p>

<p>
Verwendende Operationen: ADC, AND, ASL, BIT, CMP, DEC, EOR, INC, LDA, LDY, LSR, ORA, ROL, ROR, SBC, STA, STZ
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Absolute Indexed with X - a,x&quot;,&quot;hid&quot;:&quot;absolute_indexed_with_x_-_a_x&quot;,&quot;codeblockOffset&quot;:1,&quot;secid&quot;:22,&quot;range&quot;:&quot;14572-14933&quot;} -->
<h3 class="sectionedit23" id="absolute_indexed_with_y_-_a_y">Absolute Indexed with Y - a,y</h3>
<div class="level3">

<p>
Bei Absolute Indexed with Y-Addressing werden die kommenden 2 Byte als Basis genommen.
Auf diese wird das Y-Register aufgerechnet.
Die Bank ist der DBR.
</p>

<p>
<a href="/lib/exe/fetch.php?media=addressmode_absoluteindexedwithy.png" class="media" title="addressmode_absoluteindexedwithy.png"><img src="/lib/exe/fetch.php?w=400&amp;tok=4dd47f&amp;media=addressmode_absoluteindexedwithy.png" class="mediacenter" alt="" width="400" /></a>
</p>

<p>
Verwendende Operationen: ADC, AND, CMP, EOR, LDA, LDX, ORA, SBC, STA
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Absolute Indexed with Y - a,y&quot;,&quot;hid&quot;:&quot;absolute_indexed_with_y_-_a_y&quot;,&quot;codeblockOffset&quot;:1,&quot;secid&quot;:23,&quot;range&quot;:&quot;14934-15255&quot;} -->
<h3 class="sectionedit24" id="absolute_indirect_absolute_indirect_long_-_a_al">Absolute indirect/Absolute indirect Long - (a)/(al)</h3>
<div class="level3">

<p>
Bei Absolute indirect-Addressing wird aus den nächsten 2 Byte die Basisaddresse gebildet.
Bei Absolute indirect Addressing ist die Bank 0, bei Absolute indirect long addressing wird sie durch das 3. kommende Byte bestimmt.
</p>

<p>
Je nach  Dokument wird nicht zwischen diesen beiden unterschieden.
Die Instruktion 6c entspricht einem JMP mit Absolute Indirect.
Die Instruktion dc entspricht einem JMP mit Absolute Indirect Long (in diesem Fall dir die Operation häufig auch JML genannt)
</p>

<p>
<a href="/lib/exe/fetch.php?media=addressmode_absoluteindirect.png" class="media" title="addressmode_absoluteindirect.png"><img src="/lib/exe/fetch.php?w=400&amp;tok=9b6962&amp;media=addressmode_absoluteindirect.png" class="mediacenter" alt="" width="400" /></a>
</p>

<p>
verwendende Operationen: JML, JMP
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Absolute indirect\/Absolute indirect Long - (a)\/(al)&quot;,&quot;hid&quot;:&quot;absolute_indirect_absolute_indirect_long_-_a_al&quot;,&quot;codeblockOffset&quot;:1,&quot;secid&quot;:24,&quot;range&quot;:&quot;15256-15890&quot;} -->
<h3 class="sectionedit25" id="absolute_long_indexed_with_x_-_al_x">Absolute long indexed with X - al,x</h3>
<div class="level3">

<p>
Bei Absolute Long indexed with X-Addressing wird eine effektive Address aus den kommenden 3 Bytes gebildet.
Auf dieses wird das X-Register aufgerechnet.
Durch diese Rechnung kann sich die Bank der Addresse verändern (Sie ist nicht fest definiert).
</p>

<p>
<a href="/lib/exe/fetch.php?media=addressmode_absolutelongindexedwithx.png" class="media" title="addressmode_absolutelongindexedwithx.png"><img src="/lib/exe/fetch.php?w=400&amp;tok=8e989d&amp;media=addressmode_absolutelongindexedwithx.png" class="mediacenter" alt="" width="400" /></a>
</p>

<p>
verwendende Operationen: ADC, AND, CMP, EOR, LDA, ORA, SBC, STA
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Absolute long indexed with X - al,x&quot;,&quot;hid&quot;:&quot;absolute_long_indexed_with_x_-_al_x&quot;,&quot;codeblockOffset&quot;:1,&quot;secid&quot;:25,&quot;range&quot;:&quot;15891-16314&quot;} -->
<h3 class="sectionedit26" id="absolute_long_-_al">Absolute Long - al</h3>
<div class="level3">

<p>
Bei absolute Long-Addressing bildet sich die Addresse aus den kommenden 3 Parametern.
</p>

<p>
<a href="/lib/exe/fetch.php?media=addressmode_absolutelong.png" class="media" title="addressmode_absolutelong.png"><img src="/lib/exe/fetch.php?w=400&amp;tok=07ed65&amp;media=addressmode_absolutelong.png" class="mediacenter" alt="" width="400" /></a>
</p>

<p>
verwendende Operationen: ADC, AND, CMP, EOR, JMP, JSR, LDA, ORA, SBC, STA
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Absolute Long - al&quot;,&quot;hid&quot;:&quot;absolute_long_-_al&quot;,&quot;codeblockOffset&quot;:1,&quot;secid&quot;:26,&quot;range&quot;:&quot;16315-16556&quot;} -->
<h2 class="sectionedit27" id="direct_addressmodes">Direct addressmodes</h2>
<div class="level2">

<p>
Direct Addressmodes zeichnen sich dadurch aus, dass immer nur ein Byte als Parameter vorhanden ist und der Inhalt des D-Registers als Page verwendet wird.
Hierbei fällt auf, dass das D-Register 16-Bit groß ist und nicht 8.
Enthält das D-Register einen Wert != 0 im low-Byte so führt dies immer zu einem extra Cycle bei der Auswertung.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Direct addressmodes&quot;,&quot;hid&quot;:&quot;direct_addressmodes&quot;,&quot;codeblockOffset&quot;:1,&quot;secid&quot;:27,&quot;range&quot;:&quot;16557-16929&quot;} -->
<h3 class="sectionedit28" id="direct_indexed_indirect_-_d_x">Direct indexed indirect - (d,x)</h3>
<div class="level3">

<p>
Bei Direct Indexed Indirect wird der Parameter mit D und X verrechnet.
Dies bildet die unteren 16-Bit einer effektiven Addresse mit der Bank 00 (bis hier genau wie bei (d,x)).
Aus dieser Addresse werden 2 Byte gelesen, welche mit dem DBR die Addresse bilden.
</p>

<p>
<a href="/lib/exe/fetch.php?media=addressmode_directindexedindirect.png" class="media" title="addressmode_directindexedindirect.png"><img src="/lib/exe/fetch.php?w=400&amp;tok=a2f4be&amp;media=addressmode_directindexedindirect.png" class="mediacenter" alt="" width="400" /></a>
</p>

<p>
verwendende Operationen: ADC, AND, CMP, EOR, LDA, ORA, SBC, STA
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Direct indexed indirect - (d,x)&quot;,&quot;hid&quot;:&quot;direct_indexed_indirect_-_d_x&quot;,&quot;codeblockOffset&quot;:1,&quot;secid&quot;:28,&quot;range&quot;:&quot;16930-17356&quot;} -->
<h3 class="sectionedit29" id="direct_indexed_with_x_-_d_x">Direct indexed with X - (d,x)</h3>
<div class="level3">

<p>
Bei Direct Indexed With X werden die unteren 16-Bit gebildet, indem der Parameter mit D und X verrechnet wird.
Die Bank ist 00.
</p>

<p>
<a href="/lib/exe/fetch.php?media=addressmode_directindexedwithx.png" class="media" title="addressmode_directindexedwithx.png"><img src="/lib/exe/fetch.php?w=400&amp;tok=60a1fa&amp;media=addressmode_directindexedwithx.png" class="mediacenter" alt="" width="400" /></a>
</p>

<p>
verwendende Operationen: ADC, AND, ASL, BIT, CMP, DEC, EOR, INC, LDA, LDY, LSR, ORA, ROL, ROR, SBC, STA, STY, STZ
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Direct indexed with X - (d,x)&quot;,&quot;hid&quot;:&quot;direct_indexed_with_x_-_d_x&quot;,&quot;codeblockOffset&quot;:1,&quot;secid&quot;:29,&quot;range&quot;:&quot;17357-17697&quot;} -->
<h3 class="sectionedit30" id="direct_indexed_with_y_-_d_y">Direct indexed with Y - d,y</h3>
<div class="level3">

<p>
Bei Direct Indexed With Y werden die unteren 16-Bit gebildet, indem der Parameter mit D und Y verrechnet wird.
Die Bank ist 00.
</p>

<p>
<a href="/lib/exe/fetch.php?media=addressmode_directindexedwithy.png" class="media" title="addressmode_directindexedwithy.png"><img src="/lib/exe/fetch.php?w=400&amp;tok=742f78&amp;media=addressmode_directindexedwithy.png" class="mediacenter" alt="" width="400" /></a>
</p>

<p>
verwendende Operationen: LDX, STX
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Direct indexed with Y - d,y&quot;,&quot;hid&quot;:&quot;direct_indexed_with_y_-_d_y&quot;,&quot;codeblockOffset&quot;:1,&quot;secid&quot;:30,&quot;range&quot;:&quot;17698-17956&quot;} -->
<h3 class="sectionedit31" id="direct_indirect_indexed_-_d_y">Direct indirect indexed - (d),y</h3>
<div class="level3">

<p>
Bei Direct Indirect Indexed-Addressing wird zuerst der Parameter mit D verrechnet um einen Pointer in der Bank 0 zu formen.
Von dieser Addresse werden anschließend 16 Bit geladen mit dem DBR als Bank.
Hierauf wird dann Y addiert.
Dadurch kann sich die Bank ändern (Sie ist nicht genau definiert).
</p>

<p>
Dieser Modus ist identisch mit [d],y mit der Ausnahme, dass DBR als Bank genutzt wird.
</p>

<p>
<a href="/lib/exe/fetch.php?media=addressmode_directindirectindexed.png" class="media" title="addressmode_directindirectindexed.png"><img src="/lib/exe/fetch.php?w=400&amp;tok=f2f607&amp;media=addressmode_directindirectindexed.png" class="mediacenter" alt="" width="400" /></a>
</p>

<p>
verwendende Operationen: ADC, AND, CMP, EOR, LDA, ORA, SBC, STA
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Direct indirect indexed - (d),y&quot;,&quot;hid&quot;:&quot;direct_indirect_indexed_-_d_y&quot;,&quot;codeblockOffset&quot;:1,&quot;secid&quot;:31,&quot;range&quot;:&quot;17957-18511&quot;} -->
<h3 class="sectionedit32" id="direct_indirect_long_indexed_-_d_y">Direct Indirect Long Indexed - [d],y</h3>
<div class="level3">

<p>
Bei Direct Indirect Long Indexed-Addressing wird zuerst der Parameter mit D verrechnet um einen Pointer in der Bank 0 zu formen.
Von dieser Addresse werden anschließend eine effektive Addresse geladen (3 Byte) (Bis hierhin identisch mit [d]).
Hierauf wird zuletzt Y addiert.
Dadurch kann sich die Bank ändern (Sie ist nicht genau definiert).
</p>

<p>
Dieser Modus ist identisch mit (d),y mit der Ausnahme, dass eine effektive Addresse geladen wird udn nicht nur 2 Byte.
</p>

<p>
<a href="/lib/exe/fetch.php?media=addressmode_directindirectlongindexed.png" class="media" title="addressmode_directindirectlongindexed.png"><img src="/lib/exe/fetch.php?w=400&amp;tok=d7e93f&amp;media=addressmode_directindirectlongindexed.png" class="mediacenter" alt="" width="400" /></a>
</p>

<p>
verwendende Operationen: ADC, AND, CMP, EOR, LDA, ORA, SBC, STA
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Direct Indirect Long Indexed - [d],y&quot;,&quot;hid&quot;:&quot;direct_indirect_long_indexed_-_d_y&quot;,&quot;codeblockOffset&quot;:1,&quot;secid&quot;:32,&quot;range&quot;:&quot;18512-19152&quot;} -->
<h3 class="sectionedit33" id="direct_indirect_long_-_d">Direct indirect Long - [d]</h3>
<div class="level3">

<p>
Bei Direct indirect long-indexing wird ein Pointer in Bank 0 gebildet, indem der Parameter mit D verrechnet wird.
Aus dieser Address wird eine neue Addresse geladen (3 Byte).
</p>

<p>
<a href="/lib/exe/fetch.php?media=addressmode_directindirectlong.png" class="media" title="addressmode_directindirectlong.png"><img src="/lib/exe/fetch.php?w=400&amp;tok=63e4ec&amp;media=addressmode_directindirectlong.png" class="mediacenter" alt="" width="400" /></a>
</p>

<p>
verwendende Operationen: ADC, AND, CMP, EOR, LDA, ORA, SBC, STA
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Direct indirect Long - [d]&quot;,&quot;hid&quot;:&quot;direct_indirect_long_-_d&quot;,&quot;codeblockOffset&quot;:1,&quot;secid&quot;:33,&quot;range&quot;:&quot;19153-19487&quot;} -->
<h3 class="sectionedit34" id="direct_indirect_-_d">Direct indirect - (d)</h3>
<div class="level3">

<p>
Bei der Direct Indirect-Addressierung wird der Parameter mit D verrechnet und als Basis für einen Point in der Pank 0 genutzt.
Aus dieser Addresse werden 126 Bit geladen, welche mit dem DBR als Bank die endgültige Addresse bilden.
</p>

<p>
<a href="/lib/exe/fetch.php?media=addressmode_directindirect.png" class="media" title="addressmode_directindirect.png"><img src="/lib/exe/fetch.php?w=400&amp;tok=566479&amp;media=addressmode_directindirect.png" class="mediacenter" alt="" width="400" /></a>
</p>

<p>
verwendende Operationen: ADC, AND, CMP, EOR, LDA, ORA, SBC, STA
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Direct indirect - (d)&quot;,&quot;hid&quot;:&quot;direct_indirect_-_d&quot;,&quot;codeblockOffset&quot;:1,&quot;secid&quot;:34,&quot;range&quot;:&quot;19488-19871&quot;} -->
<h3 class="sectionedit35" id="direct_-_d">Direct - d</h3>
<div class="level3">

<p>
Bei Direct-Addressing bildet D zusammen mit dem Parameter die Addresse in der Bank 0.
</p>

<p>
<a href="/lib/exe/fetch.php?media=addressmode_direct.png" class="media" title="addressmode_direct.png"><img src="/lib/exe/fetch.php?w=400&amp;tok=9fe27a&amp;media=addressmode_direct.png" class="mediacenter" alt="" width="400" /></a>
</p>

<p>
verwendende Operationen: ADC, AND, ASL, BIT, CMP, CPX, CPY, DEC, EOR, INC, LDA, LDX, LDY, LSR, ORA, ROL, ROR, SBC, STA, STX, STY, STZ, TRB, TSB
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Direct - d&quot;,&quot;hid&quot;:&quot;direct_-_d&quot;,&quot;codeblockOffset&quot;:1,&quot;secid&quot;:35,&quot;range&quot;:&quot;19872-20169&quot;} -->
<h2 class="sectionedit36" id="andere_addressmodes">Andere Addressmodes</h2>
<div class="level2">

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Andere Addressmodes&quot;,&quot;hid&quot;:&quot;andere_addressmodes&quot;,&quot;codeblockOffset&quot;:1,&quot;secid&quot;:36,&quot;range&quot;:&quot;20170-20202&quot;} -->
<h3 class="sectionedit37" id="accumulator_-_a">Accumulator - A</h3>
<div class="level3">

<p>
Der Parameter ist der Wert des A-Registers.
</p>

<p>
verwendende Operationen: ASL, DEA, DEC, INA, INC, LSR, ROL, ROR
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Accumulator - A&quot;,&quot;hid&quot;:&quot;accumulator_-_a&quot;,&quot;codeblockOffset&quot;:1,&quot;secid&quot;:37,&quot;range&quot;:&quot;20203-20339&quot;} -->
<h3 class="sectionedit38" id="block_move_-_xyc">Block Move - xyc</h3>
<div class="level3">

<p>
Block Move-Addressing ist ein spezieller Addressmode, welche mit den MVN und MVP Operationen verwendet wird.
Das erste folgende Byte wird dabei in den DBR kopiert und dient als Zielbank mit Y als Addresse.
Das zweite folgende Byte dient als Quellbank und wir mit X als Addresse verwendet.
</p>

<p>
<a href="/lib/exe/fetch.php?media=addressmode_blockmove.png" class="media" title="addressmode_blockmove.png"><img src="/lib/exe/fetch.php?w=400&amp;tok=fa2a36&amp;media=addressmode_blockmove.png" class="mediacenter" alt="" width="400" /></a>
</p>

<p>
verwendende Operationen: MVN, MVP
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Block Move - xyc&quot;,&quot;hid&quot;:&quot;block_move_-_xyc&quot;,&quot;codeblockOffset&quot;:1,&quot;secid&quot;:38,&quot;range&quot;:&quot;20340-20739&quot;} -->
<h3 class="sectionedit39" id="immediate">Immediate - #</h3>
<div class="level3">

<p>
Bei Immediate werden die kommenden Bytes direkt als Wert an die Operation weitergegeben ohne Verrechnung.
Je nach Instruktion werden hierfür entweder die nächsten 2 oder nur das nächste 1 Byte geladen.
Für P-Operationen (REP, SEP) wird immer nur 1 Byte geladen.
Operationen auf X oder Y (CPX, CPY, LDX, LDY) brauchen 1 Byte, wenn das jeweilige Register im 8-Bit-Modus ist, ansonsten 2 Byte.
Alle anderen Operationen beziehen sich auf A und brauchen entsprechend der größe von A.
</p>

<p>
verwendende Operationen: ADC, AND, BIT, CMP, CPX, CPY, EOR, LDA, LDX, LDY, ORA, REP, SBC, SEP
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Immediate - #&quot;,&quot;hid&quot;:&quot;immediate&quot;,&quot;codeblockOffset&quot;:1,&quot;secid&quot;:39,&quot;range&quot;:&quot;20740-21345&quot;} -->
<h3 class="sectionedit40" id="implied_-_i">Implied - i</h3>
<div class="level3">

<p>
Mit implied sind alle Operationen gekennzeichnet, welche keine weiteren Parameter brauchen, da sich alle benötigten Daten aus der Operation selbst ergeben.
</p>

<p>
verwendende Operationen: CLC, CLD, CLI, CLV, DEX, DEY, INX, INY, NOP, SEC, SED, SEI, STP, TAX, TAY, TCD, TCS, TDC, TSC, TSX, TXA, TXS, TXY, TYA, TYX, WAI, XBA, XCE
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Implied - i&quot;,&quot;hid&quot;:&quot;implied_-_i&quot;,&quot;codeblockOffset&quot;:1,&quot;secid&quot;:40,&quot;range&quot;:&quot;21346-21691&quot;} -->
<h3 class="sectionedit41" id="program_counter_relative_long_-_rl">Program counter relative long - rl</h3>
<div class="level3">

<p>
Bei der Program counter relative long-Addressierung werden die nächsten 2 Byte geladen und als vorzeichenbelastete Zahl gewertet.
Diese Zahl ist ein Offset, welcher auf dern PC gerechnet wird, welcher bereits auf die nächte Instruktion zeigt.
</p>

<p>
verwendende Operationen: BRL
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Program counter relative long - rl&quot;,&quot;hid&quot;:&quot;program_counter_relative_long_-_rl&quot;,&quot;codeblockOffset&quot;:1,&quot;secid&quot;:41,&quot;range&quot;:&quot;21692-22013&quot;} -->
<h3 class="sectionedit42" id="program_counter_relative_-_r">Program counter relative - r</h3>
<div class="level3">

<p>
Bei der Program counter relative long-Addressierung werden das nächste 1 Byte geladen und als vorzeichenbelastete Zahl gewertet.
Diese Zahl ist ein Offset, welcher auf dern PC gerechnet wird, welcher bereits auf die nächte Instruktion zeigt.
</p>

<p>
verwendende Operationen: BCC, BCS, BEQ, BMI, BNE, BPL, BRA, BVC, BVS
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Program counter relative - r&quot;,&quot;hid&quot;:&quot;program_counter_relative_-_r&quot;,&quot;codeblockOffset&quot;:1,&quot;secid&quot;:42,&quot;range&quot;:&quot;22014-22368&quot;} -->
<h3 class="sectionedit43" id="stack_-_s">Stack - s</h3>
<div class="level3">

<p>
Mit Stack werden alle Operationen gekennzeichnet, welche auf dem stack operieren.
</p>

<p>
verwendende Operationen: BRK, COP, PEA, PEI, PER, PHA, PHB, PHD, PHK, PHP, PHX, PHY, PLA, PLB, PLD, PLP, PLX, PLY, RTI, RTL, RTS
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Stack - s&quot;,&quot;hid&quot;:&quot;stack_-_s&quot;,&quot;codeblockOffset&quot;:1,&quot;secid&quot;:43,&quot;range&quot;:&quot;22369-22602&quot;} -->
<h3 class="sectionedit44" id="stack_relative_-_d_s">Stack relative - d,s</h3>
<div class="level3">

<p>
Stack relative-Addressing ist eine Sonderform des Direct-Addressing, bei dem S anstelle von D verwendet wird.
Der Parameter (1 Byte) wird mit S addiert und die Bank ist 00.
</p>

<p>
<a href="/lib/exe/fetch.php?media=addressmode_stackrelative.png" class="media" title="addressmode_stackrelative.png"><img src="/lib/exe/fetch.php?w=400&amp;tok=b64220&amp;media=addressmode_stackrelative.png" class="mediacenter" alt="" width="400" /></a>
</p>

<p>
verwendende Operationen: ADC, AND, CMP, EOR, LDA, ORA, SBC, STA
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Stack relative - d,s&quot;,&quot;hid&quot;:&quot;stack_relative_-_d_s&quot;,&quot;codeblockOffset&quot;:1,&quot;secid&quot;:44,&quot;range&quot;:&quot;22603-22924&quot;} -->
<h3 class="sectionedit45" id="stack_relative_indirect_indexed_-_d_s_y">Stack relative indirect indexed - (d,s),y</h3>
<div class="level3">

<p>
S wird mit dem nächsten Byte verrechnet, um einen Pointer in Bank 00 zu formen.
Hier werden 16 Bit ausgelesen, welche die Basisadresse in Bank DBR bilden.
Diese Addresse wird abschließend mit Y verrechnet.
Dadurch kann sich die Bank ändern (Die Bank ist nicht genau definiert)
</p>

<p>
<a href="/lib/exe/fetch.php?media=addressmode_stackrelativeindirectindexed.png" class="media" title="addressmode_stackrelativeindirectindexed.png"><img src="/lib/exe/fetch.php?w=400&amp;tok=e2e906&amp;media=addressmode_stackrelativeindirectindexed.png" class="mediacenter" alt="" width="400" /></a>
</p>

<p>
verwendende Operationen: ADC, AND, CMP, EOR, LDA, ORA, SBC, STA
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Stack relative indirect indexed - (d,s),y&quot;,&quot;hid&quot;:&quot;stack_relative_indirect_indexed_-_d_s_y&quot;,&quot;codeblockOffset&quot;:1,&quot;secid&quot;:45,&quot;range&quot;:&quot;22925-23389&quot;} -->
<h1 class="sectionedit46" id="instructions">Instructions</h1>
<div class="level1">

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Instructions&quot;,&quot;hid&quot;:&quot;instructions&quot;,&quot;codeblockOffset&quot;:1,&quot;secid&quot;:46,&quot;range&quot;:&quot;23390-&quot;} -->