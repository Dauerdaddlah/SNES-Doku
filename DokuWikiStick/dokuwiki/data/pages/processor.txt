[[https://github.com/gilligan/snesdev/blob/master/docs/65816.txt]]
[[http://datasheets.chipdb.org/Western%20Design/w65c816s.pdf]]
{{ :w65c816s.pdf |}}
[[https://wiki.superfamicom.org/65816-reference]]
[[http://www.6502.org/tutorials/65c816opcodes.html#5.1.2]]

Das SNES hat einen abgewandelten Prozessor zum Western Digital W65C816S.
Dieser arbeitet mit 92 Operationen, 24 Addressmodes, 6 16-BIT Register(A, PC, X, Y, D, S) und 3 8-BIT Registern (P, PBR, DBR)

====== Allgemein ======

Der SNES-Prozessor arbeitet Little Endian (LE).
Das heißt Words (Java Shorts) werden in der Reihenfolge Low-Byte High-Byte gespeichert, Long in der Reihenfolge Low-Byte High-Byte Long-Byte.

====== Register ======
Um arbeiten zu können hat der Prozessor eine Anzahl an Register, welcher (mehr oder minder) beliebig genutzt werden können.
Ein Register ist immer 8- oder 16-BIT groß - ein 16-BIT Register kann aber auch als 8-BIT Register verwendet werden.
wird ein 'volles' Register ($FF bei 8-BIT, $FFFF bei 16-BIT) weiter erhöht oder ein 'leeres' Register ($0000) gesenkt so gibt es einen Überlauf ($FF -> $00).
**Achtung** wird ein 16-BIT Register als 8-BIT verwendet, so passirt der Überlauf auch auf 8-BIT.
Sprich wird z. B. der Accumulator als 8-BIT genutzt und hat den Wert $12FF wird sein nächster Wert $1200 sein und nicht $1300.


^ Register ^ Größe ^ Beschreibung ^
| PC | 16-BIT | **P**rogram **C**ounter - die 16-BIT Adresse innerhalb der aktuellen Bank (PBR) welche aktuel selektiert ist. Diese Adresse wird genutzt, um den nächsten Befehl zu holen oder um Addressmodi aufzulösen |
| P | 8-BIT | Statusregister - hält 8 Status (1 je Bit) als Folge der vorangegangenen Operationen |
| PBR | 8-BIT | **P**rogram **B**ank **R**egister - enthält die Bank für den aktuellen/nächsten Befehl (PC). Wird ebenfalls für einige Addressmodi verwendet |
| DBR | 8-BIT | **D**ata **B**ank **R**egister - wie PBR, wird für einige Addressmodi verwendet |
| A | 8/16-BIT | **A**ccumulator - Der accumulator wird für so ziemlich alle internen REchnungen verwendet, er ist das 'Hilfsregister'. Er hält **immer** 16-BIT, je nach Prozessormodus und P wird er jedoch u. U. als 8-BIT Register verwendet. In diesem Fall bleibt das höhere Byte erhalten und kann mit einer speziellen Operation als zusätzlicher Speicher verwendet werden. |
| X/Y | 8/16-BIT | das X und das Y-Register ist jeweils ein weiteres Hilfsregister, wie der Accumulator um Aktionen auszuführen. Je nach P wird es als 8 oder 16-BIT Register verwendet. Wenn es als 8-BIT Register genutzt wird ist das höhere (ungenutzte) Byte immer $00 |
| D | 16-BIT | **D**irect Register - wird für alle Direct-Addressmodi verwendet. Das Direct Register wird immer dann verwendet, wenn der Addressmodus nur 1 Byte erhält und soll die Page darstellen. Insofern hat diesen Register in der Regel die Form $xx00. Sollte das untere Byte einen anderen Wert haben führt dies in der Regel zu einem zusätzlich benötigten Cycle |
| S | 8/16-Bit | **S**tack Register - verwaltet die nächste zu verwendende Addresse auf dem Stack. Je nach Prozessormodus wird dieser Pointer asl 8- oder 16-BIT verwendet. Im 8-BIT modus ist dabei das höhere Byte immer $01 |

===== Program Counter (PC) =====

Der Program Counter ist ein 16-BIT Register, das sehr eng mit dem PBR zusammenarbeiten.
Er zeigt auf die nächste auszuführende Instruktion innerhalb des PBR (PBR|PC bilden die effektive Addresse).
wann immer ein Wert mit Hilfe des PC gelesen wird, wird dieser um 1 erhöht.
Werden für den Addressmodus noch weitere Werte benötigt werden diese (soweit nicht anders beschrieben) mit Hilfe des PC geholt.

==== Direct Page/Zero Page (D) ====

Die Zero Page aus dem originalen 6502 (NES) wurde im SNES Prozessor nach Direct Page umbenannt.
Immer wenn ein Addressmodus mit einem Byte gewählt wird bestimmt die Direct Page die Page-Adresse (mittleres Byte)
Die Direct Page ist 16-Bit groß und kann dementsprechend neben der Page auch einen Versatz für das Byte beinhalten, jedoch wird in dem Fall (Low-Byte != 0) ein Cycle mehr benötigt.
Im Emulation Mode ist die Adressierung in der Direct Page gefangen, sprich ein Rollover nach $FF beginnt wieder bei $00 der Direct Page (NES).
Im Native Mode hingegen geht ein Rollover in die nächste Page.
Beispiel:
<code>
LDX #$2c
LDA ($E0,X)
</code>
In Emulation Mode ergibt dies die Adresse $0C, im Native Mode $10C

==== Stack Pointer (S) ====

Der Stack Pointer ist 16-Bit groß und zeigt auf die nächste leere (zu nutzende) Speicheradresse für den Stack.
Im Emulation Mode wird das High-Byte (Page) immer auf $01 gezwungen (NES).
Der Stack Pointer wird entsprechend im Emulation Mode als 8-Bit Register gehandelt.
In der Regel ist/wird der Stack Pointer zum Programmstart auf $01FF initialisiert.
Wird ein Element auf dem Stack abgelegt, so wird der Wert auf die Adresse des Stack Pointers gelegt und dieser anschließend um 1 gesenkt.
Der Pull geschieht entsprechend umgekehrt, erst wird der Pointer incrementiert und anschließend wird der Wert gelesen.

==== Program Bank Register (PBR) ====

Der PBR ist ein 8-Bit Register welches die Bank zum PC beschreiben.
Der PBR wird immer verwendet, wenn das nächste Byte im Ablauf geholt wird, entweder die Instruktion, oder direkt darauf folgenden Bytes für den Addresmodus.

==== Data Bank register (DBR) ====

Der DBR ist ein 8-Bit Register welches die Bank für bestimmte Addressmodi hält.

==== Status Register (P) ====

das StatusRegister besteht aus den Flags NVMXDIZC.
Im Emulation Mode ist es NV1BDIZC.
Das M- und X-Flag dient dazu Accumulator, X und Y zwischen 8 und 16-Bit zu wechseln.
Dementsprechend werden diese im Emulation Mode anders verwendet:
Die Flags:
  * N - Negative steht für einen negativen Wert.
  * V - Overflow zeigt an, wenn für eine Aktion ein zusätzliches Byte benötigt worden wäre
  * M - Memory/Accumulator schaltet den Accumulator auf 16-Bit wenn auf 0 gesetzt. Im Emulation Mode ist dieser auf 1 gezwungen
  * X - Index schaltet X und Y auf 16-Bit wenn auf 0 gesetzt. Wird im Emulation Mode auf 1 gesetzt und als B gehandelt.
  * B - Break beschreibt das X-Flag im Emulation mode. Es eig. immer 1 im Register und wird bei einem Interrupt als 0 gepusht, wenn der Interrupt nicht durch ein BRK ausgelöst wurde.
  * D - decimal, wenn auf 1, dann werden ADC und SBC im decimal mode berechnet ($20 - $04 = $16)
  * I - IRQ-Disable wenn auf true, werden keine Interrupts ausgeführt außer NMI
  * Z - Zero, wird bei null gestzt, zeigt ebenfalls gleichheit an. beq - branch if equal springt bei Z = 1
  * C - Carry wird als zusätzliches Bit für einige Operationen verwendet. C und XCE sind der einzige Weg des Prozessormodus anzupassen.

{{:statusregister.png?direct&800|}}

==== Accumulator (A) ====

Der Accumulator ist einer der Hauptregister mit denen gearbeitet wird.
Er wird hauptsächlich verwendet, wenn man Daten lesen schreiben und verrechnen möchte.
Er ist 16-Bit groß und kann im 8-Bit Modus verwendet werden (je nach P).
Im Gegensatz zu allen anderen "variablen" Register behält der Accumulator den Wert seines High-Byte bei.
So kann das High-Byte im 8-Bit modus als zusätzlicher Speicher verwendet werden.
Mit Hilfe der XBA instruktion kann so der Wert des High und des Low-Bytes getauscht werden.

je nach Situation hat der Accumulator drei Namen, A, B und C.
Mit C ist der Accumulator immer als 16-Bit Register bezeichnet.
Dementsprechend tauscht die Instruktion TCS immer die kompletten 16-Bit von A (C) nach S.
B beschreibt immer das High-Byte des Accumulators.
A beschreibt je nach Kontext entweder den Accumulator allgemein oder nur das LOW-Byte (z. B. in XBA - exchange B and A).
Einige Assembler nehmen diese Trennund nicht 100% und erlauben so auch z. B. die Operation TAS als Synonym für TCS.

==== X/Y Register (X/Y) ====

X und Y sind 2 Hilfsregister, welche zusammen mit dem Accumulator verwendet werden.
Sie sind 16-BIT groß und können je nach P auch als 8-Bit verwendet werden.
Werden Sie als 8-Bit verwendet ist das High-Byte immer 0

===== Prozessormodi =====

Der Prozesser hat 2 Modi, Emulation und Native.
Bei Start des Prozessors ist dieser immer im Emulation Mode und der PC zeigt auf den Reset-Vector.
Der Modus wird über die XCE-Instruktion gesetzt, wobei ein gesetztes C-Flag den Native-Mode aktiviert.
Im Emulation Mode ist der Prozessor kompatibel zum NES 6502, dementsprechend sind alle variablen Register im 8-BIT Modus.
Im Native-Mode können A, X, und Y je nach P als 16-Bit verwendet werden - S ist automatisch 16-BIT.
Die Interrupt-Handler sind unterschiedlich je nach Modus:
^ Adresse Emulation ^ Vector Emulation ^ Adresse Native ^ Vector Native ^
| $FFF4-5 | COP     | $FFE4-5 | COP |
| $FFF6-7 |         | $FFE6-7 | BRK |
| $FFF8-9 | ABORT   | $FFE8-9 | ABORT |
| $FFFA-B | NMI     | $FFEA-B | NMI |
| $FFFC-D | RESET   | $FFEC-D | RESET (ungenutzt) |
| $FFFE-F | IRQ/BRK | $FFEE-F | IRQ |

Da der Prozessor beim Startup immer im Emulation-Mode ist wird der Reset-Vector vom Native-Mode nicht genutzt.

===== Stack Operationen =====

Auf den Stack können einzelne Bytes oder Word gepusht werden.
Wenn immer ein Wert auf den Stack gepusht wird, wird der Stackpointer um 1 reduziert.
Wird ein Word gepusht, wird zuerst das High-Byte und anschließend das Low-Byte gepusht, sodass das Word im Speicher wieder in Little-Endian steht.
Wird ein Byte gepusht, wird zuerst der Wert im gespeichert und anschließend der Pointer dekrementiert.

===== Interrupts =====

Wenn ein Interrupt ausgelöst wird werden alle nötigen Register auf den Stack gepusht und je nach Modus zum Interrupthandler gesprungen.
Zusätzlich wird PBR auf 0 gesetzt, sodass sich ein Interrupthandler immer in der Bank 0 befindet.
Außerdem wird das IRQDisable-Flag auf 1 gesetzt (D auf 0), um weitere interrupts zu vermeiden.
Mithilfe von rti (0x40) wird zum vorherigen Zustand zurückgesprungen.
Folgende Werte werden in dieser Reihenfolge gepusht und bei rti umgedreht gepullt:
  * PBR (Native Mode)
  * PC (Short)
  * P

Ein Interrupt findet nicht statt, wenn das IRQ-Disable flag true ist.
Ausnahme hiervon ist der NMI, welcher nicht über P verhindert werden kann.

====== Operationen ======

Es gibt folgende Operationen:

^ Operation ^ Alternativ ^ Beschreibung ^ verwendete Addressmodes ^ flags ^
| [[#ADC]] | | Add with Carry | a, a,x, a,y, al, al,x, d, (d,x), d,x, (d), (d),y, [d], [d],y, #, d,s, (d,s),y |  	NV----ZC |
| [[#AND]] | | And Memory and Accumulator | a, a,x, a,y, al, al,x, d, (d,x), d,x, (d), (d),y, [d], [d],y, #, d,s, (d,s),y | N-----Z- |
| [[#ASL]] | | Shift left Memory or Accumulator | a, a,x, A, d, d,x | N-----ZC |
| [[#BCC]] | | Branch if carry clear | r | |
| [[#BCS]] | | Branch if carry set | r | |
| [[#BEQ]] | | Branch if Equal/zero set | r | |
| [[#BIT]] | | Bit test | a, a,x, d, d,x, # | NV----Z-* |
| [[#BMI]] | | Branch if minus/Negative clear | r | |
| [[#BNE]] | | Branch if not equal/zero clear | r | |
| [[#BPL]] | | Branch if plus/negative clear | r | |
| [[#BRA]] | | Branch always | r | |
| [[#BRK]] | | Force Break (Interrupt) | s | ----DI-- |
| [[#BRL]] | | Branch always long | rl | |
| [[#BVC]] | | Branch if overflow clear | r | |
| [[#BVS]] | | Branch if overflow set | r | |
| [[#CLC]] | | Clear carry flag | i |
| [[#CLD]] | | Clear decimal flag | i |
| [[#CLI]] | | Clear interrupt flag | i |
| [[#CLV]] | | Clear overflow flag | i |
| [[#CMP]] | CPA | Compare with Accumulator | a, a,x, a,y, al, al,x, d, (d,x), d,x, (d), (d),y, [d], [d],y, #, d,s, (d,s),y | N-----ZC |
| [[#COP]] | | Coprocessor (Interrupt) | s | ----DI-- |
| [[#CPX]] | | Compare with X | a, d, # | N-----ZC |
| [[#CPY]] | | Compare with Y | a, d, # | N-----ZC |
| [[#DEC]] | DEA | Decrement Memory or accumulator | a, a,x, A, d, d,x | N-----Z- |
| [[#DEX]] | | Decrement X | i | N-----Z- |
| [[#DEY]] | | Decrement Y | i | N-----Z- |
| [[#EOR]] | | exclusive or with memory or accumulator | a, a,x, a,y, al, al,x, d, (d,x), d,x, (d), (d),y, [d], [d],y, #, d,s, (d,s),y | N-----Z- |
| [[#INC]] | INA | Increment memory or accumulator | a, a,x, A, d, d,x | N-----Z- |
| [[#INX]] | | Increment X | i | N-----Z- |
| [[#INY]] | | Increment Y | i | N-----Z- |
| [[#JMP]] | JML | jump long | a, (a,x), (a), (al), al | |
| [[#JSR]] | JSL | Jump to subroutine long | a, (a,x), al | |
| [[#LDA]] | | Load A | a, a,x, a,y, al, al,x, d, (d,x), d,x, (d), (d),y, [d], [d],y, #, d,s, (d,s),y | N-----Z- |
| [[#LDX]] | | Load X | a, a,y, d, d,y, # | N-----Z- |
| [[#LDY]] | | Load Y | a, a,x, d, d,x, # | N-----Z- |
| [[#LSR]] | | Shift right memory or accumulator | a, a,x, A, d, d,x | N-----ZC |
| [[#MVN]] | | Move block negative | xyc |
| [[#MVP]] | | Move block positive | xyc |
| [[#NOP]] | | No Operation | i |
| [[#ORA]] | | OR with accumulator | a, a,x, a,y, al, al,x, d, (d,x), d,x, (d), (d),y, [d], [d],y, #, d,s, (d,s),y | N-----Z- |
| [[#PEA]] | | Push effective Address/Push immediate | s |
| [[#PEI]] | | Push effective absolute address/Push Direct address | s |
| [[#PER]] | | Push effective program counter relative address | s |
| [[#PHA]] | | Push A | s |
| [[#PHB]] | | Push DBR | s |
| [[#PHD]] | | Push D | s |
| [[#PHK]] | | Push PBR | s |
| [[#PHP]] | | Push P | s |
| [[#PHX]] | | Push X | s |
| [[#PHY]] | | Push Y | s |
| [[#PLA]] | | Pull A | s | N-----Z- |
| [[#PLB]] | | Pull DBR | s | N-----Z- |
| [[#PLD]] | | Pull D | s | N-----Z- |
| [[#PLP]] | | Pull P | s | NVMXDIZC |
| [[#PLX]] | | Pull X | s | N-----Z- |
| [[#PLY]] | | Pull Y | s | N-----Z- |
| [[#REP]] | | Reset Status Bits | # |
| [[#ROL]] | | Rotate Left/Shift left with carry | a, a,x, A, d, d,x | N-----ZC |
| [[#ROR]] | | Rotate Right/Shift Right with carry | a, a,x, A, d, d,x | N-----ZC |
| [[#RTI]] | | Return from interrupt | s | NVMXDIZC |
| [[#RTL]] | | Return from subroutine long | s | |
| [[#RTS]] | | Return from subroutine | s | |
| [[#SBC]] | | Subtract with carry | a, a,x, a,y, al, al,x, d, (d,x), d,x, (d), (d),y, [d], [d],y, #, d,s, (d,s),y |  NV----ZC |
| [[#SEP]] | | Set status bits | # |
| [[#SEC]] | | Set carry flag | i |
| [[#SED]] | | Set decimal flag | i |
| [[#SEI]] | | Set interrupt flag | i |
| [[#STA]] | | Store A | a, a,x, a,y, al, al,x, d, (d,x), d,x, (d), (d),y, [d], [d],y, d,s, (d,s),y |
| [[#STP]] | | Stop the clock | i |
| [[#STX]] | | Store X | a, d, d,y |
| [[#STY]] | | Store Y | a, d, d,x |
| [[#STZ]] | | Store zero | a, a,x, d, d,x |
| [[#TAX]] | | Transfer A to X | i |
| [[#TAY]] | | Transfer A to Y | i |
| [[#TCD]] | | Transfer C(A) to D | i | N-----Z- |
| [[#TCS]] | | Transfer C(A) to S | i | |
| [[#TDC]] | | Transfer D to C(A) | i | N-----Z- |
| [[#TRB]] | | Test and reset Bits | a, d | ------Z- |
| [[#TSB]] | | Test and set bits | a, d | ------Z- |
| [[#TSC]] | | Transfer S to C(A) | i | N-----Z- |
| [[#TSX]] | | Transfer S to X | i | N-----Z- |
| [[#TXA]] | | Transfer X to A | i | N-----Z- |
| [[#TXS]] | | Transfer X to S | i | |
| [[#TXY]] | | Transfer X to Y | i | N-----Z- |
| [[#TYA]] | | Transfer Y to A | i | N-----Z- |
| [[#TYX]] | | Transfer Y to X | i | N-----Z- |
| [[#WAI]] | | Wait for interrupt | i | |
| [[#WDM]] | | Reserved for future use | i |
| [[#XBA]] | | Exchange B and A in Accumulator | i |
| [[#XCE]] | | Exchange Carry and emulation flag | i |

===== Bitoperationen=====
==== AND ====
==== EOR ====
==== ORA ====
Führt eine Bitweise- Verknüpfung mit A durch und speichert das Ergebnis in A.
AND ist and Und-Verknüpfung, EOR ist exklusiv-oder und ORA ist eine Oder-Verknüpfung.
In jedem Fall wird das Zero-Flag gesetzt wenn A 0 wird und das Negative-Flag wenn A negativ wird (höchstes Bit ist 1)

==== ASL ====
==== LSR ====
==== ROL ====
==== ROR ====
Führt eine Bitverschiebung vom Operand aus und speichert das Ergebnis im Operanden.
Das Zero-Flag wird gesetzt, wenn das Ergebnis 0 ist und das Negative-Flag wenn es negativ ist.
Das Carry-Flag wird auf das Bit gesetzt, welches "rausfällt".

Das letzte Zeichen der Operation zeigt die Richtung der Bitverschiebung (R = right-shift, L = left-shift).
Bei den R-Operationen wird bei der Verschiebung das Carry-Flag eingefügt, bei den anderen fest eine 0.

==== TRB ====
==== TSB ====
Zuerst wird ein Test mit A und dem Operanden durchgeführt.
Dieser entspricht einer UND-Verknüpfung und setzt das Zero-Flag wenn das ERgebnis 0 ist.

Anschließend werden alle Bits in A auf 0 (TRB) oder 1 (TSB) gesetzt, welche im Operanden 1 sind und das Ergebnis in den Operand zurück gespielt.

Beipiel: TSB 0x05 setzt das 0. und 2. Bit von A auf 1, während TRB 0x07 das 0. 1. und 2. Bit auf 0 setzt.

===== Register-Operationen =====
==== DEC ====
==== DEX ====
==== DEY ====
==== INC ====
==== INX ====
==== INY ====
Senkt (D am Anfang) oder erhöht (I am Anfang) den Wert des Operanden um 1 und schreibt in zurück.
DEX/INX geht auf das X-Register, DEY/INY auf das Y-Register und DEC/INC entweder auf eine Speicheradresse oder das A-Register.
Anstelle von DEC/INC mit Adressmode A wird alternativ häufig auf DEA/INA genutzt.

Entsprechend dem Wert nach der Anpassung wird bei 0 das Z-Flag gesetzt und das N-Flag wenn das höchste Bit 1 ist.

==== LDA ====
==== LDX ====
==== LDY ====
Lädt einen Wert aus dem Speicher in das X (LDX), Y (LDY) oder A (LDA) Register.
Ist der WErt 0 wird das Zero-Flag gesetzt, ist das höchste Bit 1 wird das Negative-Flag gesetzt.

==== STA ====
==== STX ====
==== STY ====
==== STZ ====
Speichert einen Wert in den Speicher (Operand).
STA, STX und STY speichern den Wert des jeweiligen Registers, STZ speichert immer 0

===== Transferoperationen =====
==== TAX ====
==== TAY ====
==== TCD ====
==== TCS ====
==== TDC ====
==== TSC ====
==== TSX ====
==== TXA ====
==== TXS ====
==== TXY ====
==== TYA ====
==== TYX ====
Bei einer Transferoperation wird der Wert eines Registers in ein anderes Register kopiert.
Die Operation ist so benannt, dass das 2. Zeichen das Quell- und das 3. Zeichen das Zielregister beschreibt.
Die zu kopierenden Bytes (1 oder 2) bestimmt das Ziel-Register.

Bei einer Transferoperation werden das Negative und das Zero-Flag gesetzt (Ausnahme, wenn das Zielregister S ist wird kein Flag geändert).
Zero wird gesetzt, wenn der betrachtete Teil des Zielregisters (z. B. wenn A im 8-Bit-Modus ist nur das Low-Byte von A) am Ende 0 ist.
Analog dazu wird N auf 1 gesetzt, wenn das höchstwertige Bit des betrachteten Registers 1 ist.

Beispiele:
TCD immer 16 BIT von A (C) nach D (da C den Accumulator in 16-Bit meint und D immer 16-Bit ist).
Im Native Mode kopiert TXS immer 16-Bit da S dort immer 16-Bit groß ist.
TAX kopiert 8- oder 16-Bit je nach der Größe von X (ist X 16-Bit groß könnte man die Operation auch TCX nennen ungeachtet der Größe von A)

===== Branch-/Jumpoperationen =====
Branch- und Jump-Operationen dienen dazu von einer Stelle zu einer beliebig anderen Stelle in der Ausführung zu springen.
Der Unterschied ist, dass Branch-Operationen (starten mit B) eine einfache Abzweigung darstellen (if-else), welche immer relativ zum PC ist.
Jump-Operationen (starten mit J) hingegen springen zu einer beliebigen absoluten Adresse unabhängig vom PC.
Ein Sonderfall hiervon sind die Subroutine-Jumps (beginnen mit JS) , welche einen "Methodenaufruf darstellen, zu dem es analog auch immer ein Return (starten mit R) geben muss.

Gleich ist allen Operationen, dass keinerlei Statusflags gesetzt werden.

Bei Branch-Operationen wird der PC auf den Wert des Operanden gesetzt, wenn eine Bedingung zutrifft.
JMP entspricht dabei BRA und JML einem BRL, wobei sich nur der Addressmode unterscheidet.
Bei JSR wird zuerst der PC auf den Stack gelegt und anschließend gesprungen.
Das Pendant dazu RTS list den PC vom Stack und macht dann weiter.
JSL und RTL ist eine Sonderform von JSR und RTS bei der in eine beliebige Bank gesprungen werden kann. Dafür wird vor dem PC noch der PBR auf den Stack gelebt, bwz. nach dem PC noch der PBR vom Stack gelesen.

==== BCC ====
Branch wenn das Carry-Flag 0 ist

==== BCS ====
Branch wenn das Carry-Flag 1 ist

==== BEQ ====
Branch wenn das Zero-Flag 1 ist (für weiter Infos siehe Vergleichsoperationen)

==== BMI ====
Branch wenn Negative-Flag 1 ist

==== BNE ====
Branch wenn Zero-Flag 0 ist (für weiter Infos size Vergleichsoperationen)

==== BPL ====
Branch wenn Negative-Flag 0 ist

==== BRA ====
Branch immer

==== BRL ====
Branch immer Long.
Dies ist die einzige Branch-Operation, bei der auch der PBR gesetzt wird.

==== BVC ====
Branch wenn Overflow-Flag 0 ist

==== BVS ====
Branch wenn Overflow-Flag 0 ist

==== JMP ====
Branch zur Adresse

==== JML ====
Branch zur Adresse in einer beliebigen Bank

==== JSL ====
==== JSR ====
==== RTL ====
==== RTS ====

===== Interruptoperationen =====
Bei einem Interrupt springt die CPU temporär zu einer anderen Stelle, um zeitkritische Aktionen auszuführen (z. B. Rendering).
Am Ende des Interrupt-Handlers steht somit immer ein RTI, um zurück zuspringen und die Bearbeitung fortzusetzen.

Wird ein Interrupt ausgelöst (per Hardware, z. B. IRQ oder NMI) wird im Native-Mode zuerst der PBR auf den Stack gelegt.
Anschließend wird immer der PC und danach P auf den Stack gelegt.
Nun wird das Decimal-Flag auf 0 und das IRQ-Flag auf 1 gesetzt und der PC wird auf den Interrupt-Handler gesetzt.
Befindet sich die CPU im Native-Mode wird zusätzlich der PBR auf 0 gesetzt.
Abschließend arbeitet die CPU den Interrupt-Handler ab.

Ist das IRQ-Flag gesetzt kann/wird kein Interrupt ausgeführt.
Die einzige Ausnahme hierzu ist der NMI, welcher immer stattfindet.

Der zugehörige Return (RTI) arbeitet auch hier wieder umgekehrt: P vom Stack lesen, PC vom Stack lesen, falls im Native-Mode PBR vom Stack lesen.

==== BRK ====
==== COP ====
BRK und COP sind spezielle Interrupts, welcher per Software ausgelöst werden können.
Obwohl sie nur 1 Byte bräuchten (kein Operand) bestehen ihre Instruktionen immer aus 2 Byte.
So kann das 2.Byte als Deskriptor verwendet werden.

Speziell bei BRK wird zusätzlich das BRK-Flag gesetzt.

==== WAI ====
Bei WAI wird die CPU "angehalten" und wartet bis ein Interrupt ausgelöst wird.
Nach einem Interrupt läuft die CPU wie gewohnt nach WAI weiter.

==== RTI ====

===== Statusflag-Operationen =====
==== CLC ====
Setze Carry-Flag auf 0

==== CLD ====
Setze Decimal-Flag auf 0

==== CLI ====
Setze IRQ-Flag auf 0

==== CLV ====
Setze Overflow-Flag auf 0

==== SEC ====
Setze Carry-Flag auf 1

==== SED ====
Setze Decimal-Flag auf 1

==== SEI ====
Setze IRQ-Flag auf 1

==== REP ====
==== SEP ====
Setze alle Bits, welche in dem Operand 1 sind auf 0 bei REP bzw. 1 bei SEP.

Beispiel: REP 0x30 setzt das 4, und 5. Status-Bit/Flag auf 0 und lässt die anderen, wie sie sind.

===== Vergleichsoperationen =====
Bei Vergleichsoperationen werden Register und Speicherstellen (oder Immediate) miteinander verglichen, um entsprechend Status-Flags zu setzen.
Hierbei wird weder das REgister noch der Speicher verändert, lediglich das Status-Register passt sich an.

Sind z. B. die zu vergleichenden Werte gleich wird zumeist das Z-Flag gesetzt so dass anschließend mit BEQ (Branch if equal, daher der Name) ein Sprung ausgeführt werden kann.

==== CMP ====
==== CPX ====
==== CPY ====
Bei diesen Operationen wird ein Register (A bei CMP, X bei CPX, Y bei CPY) mit dem Wert im Speicher (Operand) verglichen.
Man kann sich den Compare so vorstellen, das das WErt des Registers Minus den Operand-Wert genommen wird.
Ist das Ergbeniss hieraus 0 so wird das Z-Flag gesetzt, ist es Negativ wird das Negative-Flag gesetzt.
Das Carry-Flag wird immer gesetzt, wenn das ERgebnis nicht negativ ist.

==== BIT ====
Bei einem BIT-Test wird A mit dem Operandwert verundet (Bit-weises UND).
Ist das Ergebnis 0 so wird das Zero-Flag gesetzt, das Negative-Flag wird gesetzt, wenn das höchste Bit des Ergbnisse (Bit 7 im 8-Bit-Modus und BIT 15 im 16-BIT modus) 1 ist.
Zusätzlich wird das Carry-Bit auf 1 gesetzt, wenn der Wert in A größer ist als der Operand.

**Achtung Falle** Wird BIT mit dem Addressmodus Immediate genutzt (Instruktion 0x89) wird ausschließlich das Zero-Flag angepasst, alles andere bleibt unangetastet.

===== Stackoperationen =====
Es gibt essentiell nur 2 Arten von Stackoperationen: Push-Operationen, welche etwas auf den Stack ablegen (beginnen mit PE oder PH) und Pull-Operationen, welche einen WErt vom Stack holen (beginnen mit PL).
Während Push-Operationen auch "beliebige Werte" nutzen kann wird bei einem Pull immer ein Wert in ein Register gelegt.
Bei einm Pull wird dabei zusätzlich immer das Zero-Flag gesetzt, wenn der WErt 0 ist und das Negative-Flag, wenn der WErt negativ ist (das höchste Bit ist 1).

==== PEA ====
==== PEI ====
==== PER ====
PEA, PEI und PER machen effektiv das gleiche und unterscheiden sich nur durch ihren Addressmodus.
In beiden Fällen wird ein 16-Bit-Wert auf den Stack gelegt

==== PHA ====
Lege A auf den Stack.

==== PHB ====
Lege DBR auf den Stack.

==== PHD ====
Lege D auf den Stack.

==== PHK ====
Lege den PBR auf den Stack.

==== PHP ====
Lege P auf den Stack

==== PHX ====
Lege X auf den Stack

==== PHY ====
Lege Y auf den Stack

==== PLA ====
Lies A vom Stack

==== PLB ====
Lies den DBR vom Stack

==== PLD ====
Lies D vom Stack

==== PLP ====
Lies P vom Stack

==== PLX ====
Lies X vom Stack

==== PLY ====
Lies Y vom Stack

===== Sonderoperationen =====
==== ADC ====
==== SBC ====
ADC und SBC stellen die einfachsten arithmetischen Funktionen + und - dar.
Ist das Decimal-Flag auf 0 wird hierbei eine einfache Binärrechnung mit A vollzogen.
ADC rechnet A + Operand (+ a falls das Carry-Flag gesetzt ist) und schreibt das Ergebnis in A.
SBC rechnet A - Operand (- A falls das Carry-Flag gesetzt ist) und schreibt das Ergebnis in A.

Beispiel: LDA 0x25; ADC 0x04 -> 0x29

Ist das Decimal-Flag gesetzt wird A und der Operand als Binary Coded Decimal (BCD gewertet.
Dass heißt rechnen wir z. B. 0x09 + 0x03 so ergibt dies nun 0x12 und nicht 0x0C.
TODO weitere Informationen zum Rechnen in diesem Modus, falls z. B. 0x0A + 0x0B verwendet wird, etc.

folgende flags werden gesetzt:
  * Carry-flag wenn das Ergbenis größer ist als in das Register passt
  * Negative-Flag wenn das höchste Bit 1 ist
  * Zero-Flag wenn das ERgebnis 0 ist
  * Overflow-Flag wenn A und der Operand positiv waren und das Ergebnis Negativ wurde, oder umgekehrt


==== MVN ====
==== MVP ====
MVN und MVP dienen dazu große Mengen an Daten auf einmal zu kopieren.
Der Aufrud von MVN/MVP muss im vorhinein vorbereitet werde.
Das A-Register hält die Anzahl der zu kopierenden Bytes + 1, X zeigt auf die Quelladresse und Y auf die Zieladresse.
Die Quellbank ist der 1. Parameter und die Zielbank ist der 2. Parameter.

Zuerst wird die Zielbank in den DBR kopiert.
Anschließend wird ein byte von der Quelladdresse zur Zieladresse kopiert.
Nun wird A decrementiert und X und Y um 1 gesenkt (MVP) oder erhöht (MVN).
Das Kopieren und Anpassen der Register wird solange wiederholt, bis A den Wert 0xFFFF hat.

**Achtung** A wird in diesen Operationen immer als 16-Bit gewertet ungeachtet vom M-Flag

==== NOP ====
Bei NOP wird nichts gemacht

==== STP ====
Durch STP soll die Ausführung der CPU beendet werden, bis zum nächten Reset (ausschalten)

==== WDM ====
Platzhalter für evtl. noch hinzuzufügende Operation in der ZUkunft.
Nicht genutzt.

==== XCE ====
Tauscht das Carry-Flag mit dem Emulation-Flag.
Ist die CPU im Emulation-Mode wird das Emulation-Flag als 1 angesehen oder ansonsten 0.
Dies ist die einzige Möglichkeit, das CPU-Mode zu ändern

==== XBA ====
Tausch das High- und Low-Byte von A.
Mithilfe von XBA kann das High-Byte von A im Emulation-Mode (oder 8-Bit Modus) als zusätzlicher Speicher verwendet werden.

====== Addressmodes ======

Der AddressMode zeigt an, welche Daten eine Operation nutzt, bzw. wie die Daten ermittelt werden.
Es gibt für das SNES folgende Addressmodes:
^ Addressmode ^ Schema ^ Bytes ^ Bank ^ Operationen ^
| [[#Absolute - a|absolute]] | a | 2 | DBR | ADC, AND, ASL, BIT, CMP, CPX, CPY, DEC, EOR, INC, JMP, JSR, LDA, LDX, LDY, LSR, ORA, ROL, ROR, SBC, STA, STX, STY, STZ, TRB, TSB  |
| [[#Absolute indexed indirect - (a,x)|absolute indexed indirect]] | (a,x) | 2 | PBR | JMP, JSR  |
| [[#Absolute Indexed with X - a,x|absolute indexed with x]] | a,x | 2 | DBR | ADC, AND, ASL, BIT, CMP, DEC, EOR, INC, LDA, LDY, LSR, ORA, ROL, ROR, SBC, STA, STZ  |
| [[#Absolute Indexed with Y - a,y|absolute indexed with Y]] | a,y | 2 | DBR | ADC, AND, CMP, EOR, LDA, LDX, ORA, SBC, STA  |
| [[#Absolute indirect/Absolute indirect Long - (a)/(al)|absolute indirect/absolute indirect long]] | (a)/(al) | 2/3 | 00/Param | JML, JMP |
| [[#Absolute long indexed with X - al,x|absolute long indexed with x]] | al,x | 3 | Caluculated | ADC, AND, CMP, EOR, LDA, ORA, SBC, STA |
| [[#Absolute Long - al|absolute long]] | al | 3 | Param | ADC, AND, CMP, EOR, JMP, JSR, LDA, ORA, SBC, STA |
| [[#Accumulator - A|Accumulator]] | A | 0 | | ASL, DEA, DEC, INA, INC, LSR, ROL, ROR |
| [[#Block Move - xyc|Block Move]] | xyc | 2 | | MVN, MVP |
| [[#Direct indexed indirect - (d,x)|direct indexed indirect]] | (d,x) | 1 | DBR | ADC, AND, CMP, EOR, LDA, ORA, SBC, STA  |
| [[#Direct indexed with X - d,x|direct indexed with X]] | d,x | 1 | 00 | ADC, AND, ASL, BIT, CMP, DEC, EOR, INC, LDA, LDY, LSR, ORA, ROL, ROR, SBC, STA, STY, STZ |
| [[#Direct indexed with Y - d,y|direct indexed with Y]] | d,y | 1 | 00 | LDX, STX |
| [[#Direct indirect indexed - (d),y|direct indirect indexed]] | (d),y | 1 | calculated | ADC, AND, CMP, EOR, LDA, ORA, SBC, STA |
| [[#Direct Indirect Long Indexed - [d],y|direct indirect long indexed]] | [d],y | 1 | calculated | ADC, AND, CMP, EOR, LDA, ORA, SBC, STA |
| [[#Direct indirect Long - [d]|direct indirect long]] | [d] | 1 | loaded | ADC, AND, CMP, EOR, LDA, ORA, SBC, STA |
| [[#Direct indirect - (d)|direct indirect]] | (d) | 1 | DBR | ADC, AND, CMP, EOR, LDA, ORA, SBC, STA |
| [[#Direct - d|direct]] | d | 1 | 00 | ADC, AND, ASL, BIT, CMP, CPX, CPY, DEC, EOR, INC, LDA, LDX, LDY, LSR, ORA, ROL, ROR, SBC, STA, STX, STY, STZ, TRB, TSB |
| [[#Immediate - #|immediate]] | # | 1/2 | | ADC, AND, BIT, CMP, CPX, CPY, EOR, LDA, LDX, LDY, ORA, REP, SBC, SEP |
| [[#Implied - i|implied]] | i | 0 | | CLC, CLD, CLI, CLV, DEX, DEY, INX, INY, NOP, SEC, SED, SEI, STP, TAX, TAY, TCD, TCS, TDC, TSC, TSX, TXA, TXS, TXY, TYA, TYX, WAI, XBA, XCE |
| [[#Program counter relative long - rl|program counter relative long]] | rl | 2 | PBR | BRL |
| [[#Program counter relative - r|program counter relative]] | r | 1 | PBR | BCC, BCS, BEQ, BMI, BNE, BPL, BRA, BVC, BVS |
| [[#Stack - s|Stack]] | s | 0 | | BRK, COP, PEA, PEI, PER, PHA, PHB, PHD, PHK, PHP, PHX, PHY, PLA, PLB, PLD, PLP, PLX, PLY, RTI, RTL, RTS |
| [[#Stack relative - d,s|stack relative]] | d,s | 1 | 00 | ADC, AND, CMP, EOR, LDA, ORA, SBC, STA |
| [[#Stack relative indirect indexed - (d,s),y|stack relative indirect indexed]] | (d,s),y | 1 | Calculated | ADC, AND, CMP, EOR, LDA, ORA, SBC, STA |

Hierzu einige Regeln, welche man hieraus ableiten kann:
  * a (für absolute) heißt das die kommenden Bytes direkt genommen und ausgewertet werden 
  * d (für direct) im Vergleich zu a heißt immer, dass nur 1 Byte gebraucht wird und ein Register als 'Page' draufgerechnet wird. Dieses Register ist immer D ausßer bei (d,s),y wo es S ist.
  * eine Klammerung steht immer für einen Indirect-Zugriff. Das heißt es wird mit den Bytes eine Adresse aufgelöst, deren Inhalt wird als weitere Addresse verwendet, um den endgültigen Wert zu bestimmen.
  * Die eckigen Klammern [] wurden verwendet um bei direct zwischen der normalen () und der long [] Variante zu unterschieden. Hier hätte man auch alternative dl verwenden können anstelle einer neuen Klammerart
  * Ein Komma , bedeutet immer, dass das Register nach dem Komma auf den WErt aufgerechnet wird.
  * Die Darstellung zeigt den Ablauf der Auflösung z. B (a,x) heißt, es wird zuerst x aufgerechnet und dann die indirekte Auslösung, während (d),y umgekehrt arbeitet

===== Absolute Addresmodes =====

Bei Absolute AddressModes werden immer 2 oder 3 Bytes gelesen und weiterverarbeitet.
Dies sind generell die am einfachsten zu verstehenden Modi.
Die Varianten mit 3 Bytes werden dabei in der Regel mit dem Kürzel Long gekennzeichnet.

==== Absolute - a ====

Bei Absolute Addressing werden die kommenden 2 Bytes direkt als Addresse genommen.
Der DBR enthält dabei die Bank.

{{ ::addressmode_absolute.png?direct&400 |}}

BEi Absolute Addressing passiert kein Wrap-around.
Werden 2 Byte von Adresse $12FFFF gelesen, so befindet sich das erste in $12FFFF und das 2. in $130000

Verwendende Operationen: ADC, AND, ASL, BIT, CMP, CPX, CPY, DEC, EOR, INC, JMP, JSR, LDA, LDX, LDY, LSR, ORA, ROL, ROR, SBC, STA, STX, STY, STZ, TRB, TSB

==== Absolute indexed indirect - (a,x) ====

Bei der Absolute indexed Indirect Adressierung werden die kommenden 2 Bytes als Basis genommen.
Auf diese Adresse wird dann das X-Register aufgerechnet.
Die Bank ist der PBR.

{{ ::addressmode_absoluteindexedindirect.png?direct&400 |}}

Bei Absolute Indexed Indirect Adressing passier ein Bank Wrap Around.
Sind dies nächsten 2 Byte $FFFF, X ist $06 und der PBR ist $12, sow ird das low-Byte von $120005 und das Hi-Byte von $120006 gelesen.
Die Bank der endgültigen Adresse ist erneut der PBR.

verwendende Operationen: JMP, JSR

==== Absolute Indexed with X - a,x ====
==== Absolute Indexed with Y - a,y ====
Bei Absolute Indexed with X/Y-Addressing werden die kommenden 2 Byte als Basis genommen.
Auf diese wird das X/Y-Register aufgerechnet.
Die Bank ist der DBR.

{{ ::addressmode_absoluteindexedwithx.png?direct&400 |}}

{{ ::addressmode_absoluteindexedwithy.png?direct&400 |}}

Bei diesem Modus passiert kein Wrap Around.
Ist der DBR $12 und die nächsten 2 Byte geben 0xFFFF und X/Y ist 0x06 so ist das erste gelesene Byte in $130005 und das 2. in $130006.

Verwendende Operationen X: ADC, AND, ASL, BIT, CMP, DEC, EOR, INC, LDA, LDY, LSR, ORA, ROL, ROR, SBC, STA, STZ
Verwendende Operationen Y: ADC, AND, CMP, EOR, LDA, LDX, ORA, SBC, STA

==== Absolute indirect/Absolute indirect Long - (a)/(al) ====

Bei Absolute indirect-Addressing wird aus den nächsten 2 Byte die Basisaddresse gebildet.
Bei Absolute indirect Addressing ist die Bank 0, bei Absolute indirect long addressing wird sie durch das 3. kommende Byte bestimmt.

Je nach  Dokument wird nicht zwischen diesen beiden unterschieden.
Die Instruktion 6c entspricht einem JMP mit Absolute Indirect.
Die Instruktion dc entspricht einem JMP mit Absolute Indirect Long (in diesem Fall dir die Operation häufig auch JML genannt)

{{ ::addressmode_absoluteindirect.png?direct&400 |}}

Bei den Absolute Indirect Addressing passiert in Bank Wrap.
Sind die 2 kommenden Byte $FFFF so wird das low-Byte von $00FFFF und das hi-Byte von $000000 gelesen.
In JML würde das 3 Byte von $000001 gelesen.

verwendende Operationen: JML, JMP

==== Absolute long indexed with X - al,x ====

Bei Absolute Long indexed with X-Addressing wird eine effektive Address aus den kommenden 3 Bytes gebildet.
Auf dieses wird das X-Register aufgerechnet.
Durch diese Rechnung kann sich die Bank der Addresse verändern (Sie ist nicht fest definiert).

{{ ::addressmode_absolutelongindexedwithx.png?direct&400 |}}

Beim Laden der Werte passiert hier kein Wrap Around.
Ist der Operand $12FFFF und X $06 so wird aus $130005 und $130006 gelesen.

verwendende Operationen: ADC, AND, CMP, EOR, LDA, ORA, SBC, STA

==== Absolute Long - al ====

Bei absolute Long-Addressing bildet sich die Addresse aus den kommenden 3 Parametern.

{{ ::addressmode_absolutelong.png?direct&400 |}}

Beim Laden der Werte passiert hier kein Wrap Around.
Ist der Operand $12FFFF so wird aus $12FFFF und $130000 gelesen.

verwendende Operationen: ADC, AND, CMP, EOR, JMP, JSR, LDA, ORA, SBC, STA

===== Direct addressmodes =====

Direct Addressmodes zeichnen sich dadurch aus, dass immer nur ein Byte als Parameter vorhanden ist und der Inhalt des D-Registers als Page verwendet wird.
Hierbei fällt auf, dass das D-Register 16-Bit groß ist und nicht 8.
Enthält das D-Register einen Wert != 0 im low-Byte so führt dies immer zu einem extra Cycle bei der Auswertung.

Bei allen Direct-Addressmodes passiert u. U. ein Page Wrap Around, wenn das Low-Byte von D $00 ist, eine "alte" Operation genutzt wird und sich die CPU im Emulation-Mode befindet.
Ist D $1200, un die Adresse $FF so wäre dann die nächste Adresse $0012FF und die danach $001200

==== Direct indexed indirect - (d,x) ====

Bei Direct Indexed Indirect wird der Parameter mit D und X verrechnet.
Dies bildet die unteren 16-Bit einer effektiven Addresse mit der Bank 00 (bis hier genau wie bei (d,x)).
Aus dieser Addresse werden 2 Byte gelesen, welche mit dem DBR die Addresse bilden.

{{ ::addressmode_directindexedindirect.png?direct&400 |}}

Beim lesen der Adresse passiert ein Bank Wrap Around.
Zusätzlich dazu passiert ein Page Wrap Around, wenn bei einem "alten" OpCode, D den Wert $XX00 hat und wir uns im Emulation-Mode befinden.

Im Emulation-Mode, D $1200, X $06 und der Parameter ist $FF, dann wir die Adresse aus $001205 und $001206 ausgelesen.

Im Emulation-Mode, D $1201, X $06 und der Parameter ist $FF, dann wir die Adresse aus $001306 und $001307 ausgelesen.

Im Emulation-Mode, D $FF00, X $06 und der Parameter ist $FF, dann wir die Adresse aus $00FF05 und $00FF06 ausgelesen.

Im Emulation-Mode, D $FF01, X $06 und der Parameter ist $FF, dann wir die Adresse aus $000006 und $000007 ausgelesen.

Im Native-Mode, D $1200, X $06 und der Parameter ist $FF, dann wir die Adresse aus $001305 und $001306 ausgelesen.

Im Emulation-Mode, D $FF00, X $06 und der Parameter ist $FF, dann wir die Adresse aus $000005 und $000006 ausgelesen.

Ist die ermittelte Adresse nun $FFFF und der DBR $34, so wird der Wert aus $34FFFF und $350000

verwendende Operationen: ADC, AND, CMP, EOR, LDA, ORA, SBC, STA

==== Direct indexed with X - d,x ====
==== Direct indexed with Y - d,y ====

Bei Direct Indexed With X/Y werden die unteren 16-Bit gebildet, indem der Parameter mit D und X/Y verrechnet wird.
Die Bank ist 00.

{{ ::addressmode_directindexedwithx.png?direct&400 |}}
{{ ::addressmode_directindexedwithy.png?direct&400 |}}

Bei "alten" Operationen, im Emulation-Mode mit einem D von $XX00 passiert hier ein Page Wrap around.
Ist D $1200, X/Y $06und wir befinden uns im Emulation-Mode, so ist das Low-Byte in $001205 und das High-Byte in $001206.
Im Native-Mode wären es $001305 und $001306.
Wäre D $1201, so wären die Adressen $001306 und $001307.

Davon abgesehen passiert immer ein Bank Wrap Around.
Bsp: Ist D $FF00 und der Parameter $FF und X/Y ist $06 im Native-Mode so sind die Adressen $000005 und $000006.

verwendende Operationen X: ADC, AND, ASL, BIT, CMP, DEC, EOR, INC, LDA, LDY, LSR, ORA, ROL, ROR, SBC, STA, STY, STZ

verwendende Operationen Y: LDX, STX

==== Direct indirect indexed - (d),y ====

Bei Direct Indirect Indexed-Addressing wird zuerst der Parameter mit D verrechnet um einen Pointer in der Bank 0 zu formen.
Von dieser Addresse werden anschließend 16 Bit geladen mit dem DBR als Bank.
Hierauf wird dann Y addiert.
Dadurch kann sich die Bank ändern (Sie ist nicht genau definiert).

Dieser Modus ist identisch mit [d],y mit der Ausnahme, dass DBR als Bank genutzt wird.

{{ ::addressmode_directindirectindexed.png?direct&400 |}}

Die Ermittlung der Adresse ist genau wie im Direct Indirect Adressing (D + Parameter, Page Wrap Around bei Emulation-Mode + D $XX00 und "altem" OpCode, ansonsten Bank Wrap Around).
Bei der anschließenden Ermittlung des WErtes passiert ebenfalls kein Wrap Around.

Ist die Adresse $FFFF, DBR $12 und Y $06 so wird aus $130005 und $130006 ausgelesen.

verwendende Operationen: ADC, AND, CMP, EOR, LDA, ORA, SBC, STA

==== Direct Indirect Long Indexed - [d],y ====

Bei Direct Indirect Long Indexed-Addressing wird zuerst der Parameter mit D verrechnet um einen Pointer in der Bank 0 zu formen.
Von dieser Addresse werden anschließend eine effektive Addresse geladen (3 Byte) (Bis hierhin identisch mit [d]).
Hierauf wird zuletzt Y addiert.
Dadurch kann sich die Bank ändern (Sie ist nicht genau definiert).

Dieser Modus ist identisch mit (d),y mit der Ausnahme, dass eine effektive Addresse geladen wird udn nicht nur 2 Byte.

{{ ::addressmode_directindirectlongindexed.png?direct&400 |}}

Bzgl Wrap Around ist dieser Modus identisch mit Direct Indirect Indexed Adressierung, Mit den 2 Ausnahmen, dass es kein Page Wrap Aound beim ermitteln der Adresse gibt und das die Bank der Werte auch aus der Adresse ausgelesen wird.

Bsp: D ist $1200 und der Parameter ist $FF.
Die Adresse wird aus $0012FF, $001300 und $001301 ausgelesen.
Hieraus lesen wir $12FFFF und Y ist $06 so wird der Wert aus $130005 und $130006 gelesen.

verwendende Operationen: ADC, AND, CMP, EOR, LDA, ORA, SBC, STA

==== Direct indirect Long - [d] ====

Bei Direct indirect long-indexing wird ein Pointer in Bank 0 gebildet, indem der Parameter mit D verrechnet wird.
Aus dieser Address wird eine neue Addresse geladen (3 Byte).

{{ ::addressmode_directindirectlong.png?direct&400 |}}

Beim lesen der Adresse passiert ein Page Wrap Around, anschließend beim lesen des Wertes hingegen passiert kein Wrap Around mehr.

Ist D $FF00 und er Parameter $FE so wird die Adresse aus $00FFFE, $00FFFF und $000000 ausgelesen.
Sagen wir, hier kommt $12FFFF raus, so wird der Wert aus $12FFFF und $130000 ausgelesen.

verwendende Operationen: ADC, AND, CMP, EOR, LDA, ORA, SBC, STA

==== Direct indirect - (d) ====

Bei der Direct Indirect-Addressierung wird der Parameter mit D verrechnet und als Basis für einen Point in der Pank 0 genutzt.
Aus dieser Addresse werden 16 Bit geladen, welche mit dem DBR als Bank die endgültige Addresse bilden.

{{ ::addressmode_directindirect.png?direct&400 |}}

Befindet sich die CPU im Emulation-Mode, es wird ein "alter" OpCode verwendet und D ist $XX00, so passiert ein Page Wrap around beim ermitteln der Indirekten Adresse.
Davon abgesehen passiert immer ein Bank Wrap around.
Wird aus dieser Adresse gelesen, so passiert keine Wrap Around.

Im Emulation-Mode bei D $1200 und dem Parameter $FF wäre die Adresse nun in $0012FF und $001200.
Vorausgesetzt wir lesen der $FFFF und der DBR ist $34 so wird der WErt aus $34FFFF und $350000 gelesen.

Im Emulation-Mode bei D $1201 und dem Parameter $FF wäre die Adresse nun in $001300 und $001301.
Vorausgesetzt wir lesen der $FFFF und der DBR ist $34 so wird der WErt aus $34FFFF und $350000 gelesen.

Im Emulation-Mode bei D $FF00 und dem Parameter $FF wäre die Adresse nun in $00FFFF und $00FF00.
Vorausgesetzt wir lesen der $FFFF und der DBR ist $34 so wird der WErt aus $34FFFF und $350000 gelesen.

Im Emulation-Mode bei D $FF01 und dem Parameter $FF wäre die Adresse nun in $000000 und $000001.
Vorausgesetzt wir lesen der $FFFF und der DBR ist $34 so wird der WErt aus $34FFFF und $350000 gelesen.

Im Native-Mode bei D $1200 und dem Parameter $FF wäre die Adresse nun in $0012FF und $001300.
Vorausgesetzt wir lesen der $FFFF und der DBR ist $34 so wird der WErt aus $34FFFF und $350000 gelesen.

Im Native-Mode bei D $FF00 und dem Parameter $FF wäre die Adresse nun in $00FFFF und $000000.
Vorausgesetzt wir lesen der $FFFF und der DBR ist $34 so wird der WErt aus $34FFFF und $350000 gelesen.

verwendende Operationen: ADC, AND, CMP, EOR, LDA, ORA, SBC, STA

==== Direct - d ====

Bei Direct-Addressing bildet D zusammen mit dem Parameter die Addresse in der Bank 0.

{{ ::addressmode_direct.png?direct&400 |}}

Im Direct Adressing passiert ein Bank Wrap.
Ist D $FF und der Parameter ist $FF, so wird das erste Byte von $00FFFF und das zweite von $000000 gelesen.

Ist der OPCode ein "alter" (bereits bekannt in CPU 6502), das Low-Byte von D ist $00 ($XX00) und die CPU befindet sich im Emulation-Mode, dann passiert ebenfalls ein Page Wrap Around (es gibt keine OP, die diese Bedingungen trifft).
In dem Fall würde bei einem D von $34 und einem Parameter von $FF das Low-Byte aus $0034FF und das high-Byte aus $003400 gelesen.

verwendende Operationen: ADC, AND, ASL, BIT, CMP, CPX, CPY, DEC, EOR, INC, LDA, LDX, LDY, LSR, ORA, ROL, ROR, SBC, STA, STX, STY, STZ, TRB, TSB

===== Andere Addressmodes =====

==== Accumulator - A ====

Der Parameter ist der Wert des A-Registers.

verwendende Operationen: ASL, DEA, DEC, INA, INC, LSR, ROL, ROR

==== Block Move - xyc ====

Block Move-Addressing ist ein spezieller Addressmode, welche mit den MVN und MVP Operationen verwendet wird.
Das erste folgende Byte wird dabei in den DBR kopiert und dient als Zielbank mit Y als Addresse.
Das zweite folgende Byte dient als Quellbank und wir mit X als Addresse verwendet.

{{ ::addressmode_blockmove.png?direct&400 |}}

Bei diesen Instruktionen/Addressmode passiert immer ein Bank Wrap Around.
Ungeachtet der Situation bleiben die Ziel- und Quellbank unverändert.

verwendende Operationen: MVN, MVP

==== Immediate - # ====

Bei Immediate werden die kommenden Bytes direkt als Wert an die Operation weitergegeben ohne Verrechnung.
Je nach Instruktion werden hierfür entweder die nächsten 2 oder nur das nächste 1 Byte geladen.
Für P-Operationen (REP, SEP) wird immer nur 1 Byte geladen.
Operationen auf X oder Y (CPX, CPY, LDX, LDY) brauchen 1 Byte, wenn das jeweilige Register im 8-Bit-Modus ist, ansonsten 2 Byte.
Alle anderen Operationen beziehen sich auf A und brauchen entsprechend der größe von A.

Beim Immediate Adressing passiert ein Page Wrap Around.
Ist der PBR $12 und der PC $FFFF so würde hier aus $12FFFF und $130000 gelesen werden.

verwendende Operationen: ADC, AND, BIT, CMP, CPX, CPY, EOR, LDA, LDX, LDY, ORA, REP, SBC, SEP

==== Implied - i ====

Mit implied sind alle Operationen gekennzeichnet, welche keine weiteren Parameter brauchen, da sich alle benötigten Daten aus der Operation selbst ergeben.

verwendende Operationen: CLC, CLD, CLI, CLV, DEX, DEY, INX, INY, NOP, SEC, SED, SEI, STP, TAX, TAY, TCD, TCS, TDC, TSC, TSX, TXA, TXS, TXY, TYA, TYX, WAI, XBA, XCE

==== Program counter relative long - rl ====

Bei der Program counter relative long-Addressierung werden die nächsten 2 Byte geladen und als vorzeichenbelastete Zahl gewertet.
Diese Zahl ist ein Offset, welcher auf dern PC gerechnet wird, welcher bereits auf die nächte Instruktion zeigt.

Hierbei passiert ein Page Wrap Around, die Bank ist immer der PBR.

verwendende Operationen: BRL

==== Program counter relative - r ====

Bei der Program counter relative long-Addressierung werden das nächste 1 Byte geladen und als vorzeichenbelastete Zahl gewertet.
Diese Zahl ist ein Offset, welcher auf dern PC gerechnet wird, welcher bereits auf die nächste Instruktion zeigt.

Hierbei passiert ein Page Wrap Around, die Bank ist immer der PBR.

verwendende Operationen: BCC, BCS, BEQ, BMI, BNE, BPL, BRA, BVC, BVS

==== Stack - s ====

Mit Stack werden alle Operationen gekennzeichnet, welche auf dem stack operieren.

verwendende Operationen: BRK, COP, PEA, PEI, PER, PHA, PHB, PHD, PHK, PHP, PHX, PHY, PLA, PLB, PLD, PLP, PLX, PLY, RTI, RTL, RTS

==== Stack relative - d,s ====

Stack relative-Addressing ist eine Sonderform des Direct-Addressing, bei dem S anstelle von D verwendet wird.
Der Parameter (1 Byte) wird mit S addiert und die Bank ist 00.

Während bei der Adresse (wie erwartet) ein Bank Wrap Around passiert gibt es bei den Daten keinen Wrap Around

Ist S $FFFF und der Parameter $06 so wird die Adresse aus $000005 und $000006 ausgelesen.
Erhalten wir hier $FFFF, der DBR ist $12 und Y ist $06, so wird der Wert aus $130005 und $130006 ausgelesen.

{{ ::addressmode_stackrelative.png?direct&400 |}}

verwendende Operationen: ADC, AND, CMP, EOR, LDA, ORA, SBC, STA

==== Stack relative indirect indexed - (d,s),y ====

S wird mit dem nächsten Byte verrechnet, um einen Pointer in Bank 00 zu formen.
Hier werden 16 Bit ausgelesen, welche die Basisadresse in Bank DBR bilden.
Diese Addresse wird abschließend mit Y verrechnet.
Dadurch kann sich die Bank ändern (Die Bank ist nicht genau definiert)

{{ ::addressmode_stackrelativeindirectindexed.png?direct&400 |}}

verwendende Operationen: ADC, AND, CMP, EOR, LDA, ORA, SBC, STA

====== Instructions ======