[[https://github.com/gilligan/snesdev/blob/master/docs/65816.txt]]
[[http://datasheets.chipdb.org/Western%20Design/w65c816s.pdf]]
{{ :w65c816s.pdf |}}

Das SNES hat einen abgewandelten Prozessor zum Western Digital W65C816S.
Dieser arbeitet mit 92 Operationen, 24 Addressmodes, 6 16-BIT Register(A, PC, X, Y, D, S) und 3 8-BIT Registern (P, PBR, DBR)

====== Allgemein ======

Der SNES-Prozessor arbeitet Little Endian (LE).
Das heißt Words (Java Shorts) werden in der Reihenfolge Low-Byte High-Byte gespeichert, Long in der Reihenfolge Low-Byte High-Byte Long-Byte.

====== Register ======
Um arbeiten zu können hat der Prozessor eine Anzahl an Register, welcher (mehr oder minder) beliebig genutzt werden können.
Ein Register ist immer 8- oder 16-BIT groß - ein 16-BIT Register kann aber auch als 8-BIT Register verwendet werden.
wird ein 'volles' Register ($FF bei 8-BIT, $FFFF bei 16-BIT) weiter erhöht oder ein 'leeres' Register ($0000) gesenkt so gibt es einen Überlauf ($FF -> $00).
**Achtung** wird ein 16-BIT Register als 8-BIT verwendet, so passirt der Überlauf auch auf 8-BIT.
Sprich wird z. B. der Accumulator als 8-BIT genutzt und hat den Wert $12FF wird sein nächster Wert $1200 sein und nicht $1300.


^ Register ^ Größe ^ Beschreibung ^
| PC | 16-BIT | **P**rogram **C**ounter - die 16-BIT Adresse innerhalb der aktuellen Bank (PBR) welche aktuel selektiert ist. Diese Adresse wird genutzt, um den nächsten Befehl zu holen oder um Addressmodi aufzulösen |
| P | 8-BIT | Statusregister - hält 8 Status (1 je Bit) als Folge der vorangegangenen Operationen |
| PBR | 8-BIT | **P**rogram **B**ank **R**egister - enthält die Bank für den aktuellen/nächsten Befehl (PC). Wird ebenfalls für einige Addressmodi verwendet |
| DBR | 8-BIT | **D**ata **B**ank **R**egister - wie PBR, wird für einige Addressmodi verwendet |
| A | 8/16-BIT | **A**ccumulator - Der accumulator wird für so ziemlich alle internen REchnungen verwendet, er ist das 'Hilfsregister'. Er hält **immer** 16-BIT, je nach Prozessormodus und P wird er jedoch u. U. als 8-BIT Register verwendet. In diesem Fall bleibt das höhere Byte erhalten und kann mit einer speziellen Operation als zusätzlicher Speicher verwendet werden. |
| X/Y | 8/16-BIT | das X und das Y-Register ist jeweils ein weiteres Hilfsregister, wie der Accumulator um Aktionen auszuführen. Je nach P wird es als 8 oder 16-BIT Register verwendet. Wenn es als 8-BIT Register genutzt wird ist das höhere (ungenutzte) Byte immer $00 |
| D | 16-BIT | **D**irect Register - wird für alle Direct-Addressmodi verwendet. Das Direct Register wird immer dann verwendet, wenn der Addressmodus nur 1 Byte erhält und soll die Page darstellen. Insofern hat diesen Register in der Regel die Form $xx00. Sollte das untere Byte einen anderen Wert haben führt dies in der Regel zu einem zusätzlich benötigten Cycle |
| S | 8/16-Bit | **S**tack Register - verwaltet die nächste zu verwendende Addresse auf dem Stack. Je nach Prozessormodus wird dieser Pointer asl 8- oder 16-BIT verwendet. Im 8-BIT modus ist dabei das höhere Byte immer $01 |

===== Program Counter (PC) =====

Der Program Counter ist ein 16-BIT Register, das sehr eng mit dem PBR zusammenarbeiten.
Er zeigt auf die nächste auszuführende Instruktion innerhalb des PBR (PBR|PC bilden die effektive Addresse).
wann immer ein Wert mit Hilfe des PC gelesen wird, wird dieser um 1 erhöht.
Werden für den Addressmodus noch weitere Werte benötigt werden diese (soweit nicht anders beschrieben) mit Hilfe des PC geholt.

==== Direct Page/Zero Page (D) ====

Die Zero Page aus dem originalen 6502 (NES) wurde im SNES Prozessor nach Direct Page umbenannt.
Immer wenn ein Addressmodus mit einem Byte gewählt wird bestimmt die Direct Page die Page-Adresse (mittleres Byte)
Die Direct Page ist 16-Bit groß und kann dementsprechend neben der Page auch einen Versatz für das Byte beinhalten, jedoch wird in dem Fall (Low-Byte != 0) ein Cycle mehr benötigt.
Im Emulation Mode ist die Adressierung in der Direct Page gefangen, sprich ein Rollover nach $FF beginnt wieder bei $00 der Direct Page (NES).
Im Native Mode hingegen geht ein Rollover in die nächste Page.
Beispiel:
<code>
LDX #$2c
LDA ($E0,X)
</code>
In Emulation Mode ergibt dies die Adresse $0C, im Native Mode $10C

==== Stack Pointer (S) ====

Der Stack Pointer ist 16-Bit groß und zeigt auf die nächste leere (zu nutzende) Speicheradresse für den Stack.
Im Emulation Mode wird das High-Byte (Page) immer auf $01 gezwungen (NES).
Der Stack Pointer wird entsprechend im Emulation Mode als 8-Bit Register gehandelt.
In der Regel ist/wird der Stack Pointer zum Programmstart auf $01FF initialisiert.
Wird ein Element auf dem Stack abgelegt, so wird der Wert auf die Adresse des Stack Pointers gelegt und dieser anschließend um 1 gesenkt.
Der Pull geschieht entsprechend umgekehrt, erst wird der Pointer incrementiert und anschließend wird der Wert gelesen.

==== Program Bank Register (PBR) ====

Der PBR ist ein 8-Bit Register welches die Bank zum PC beschreiben.
Der PBR wird immer verwendet, wenn das nächste Byte im Ablauf geholt wird, entweder die Instruktion, oder direkt darauf folgenden Bytes für den Addresmodus.

==== Data Bank register (DBR) ====

Der DBR ist ein 8-Bit Register welches die Bank für bestimmte Addressmodi hält.

==== Status Register (P) ====

das StatusRegister besteht aus den Flags NVMXDIZC.
Im Emulation Mode ist es NV1BDIZC.
Das M- und X-Flag dient dazu Accumulator, X und Y zwischen 8 und 16-Bit zu wechseln.
Dementsprechend werden diese im Emulation Mode anders verwendet:
Die Flags:
  * N - Negative steht für einen negativen Wert.
  * V - Overflow zeigt an, wenn für eine Aktion ein zusätzliches Byte benötigt worden wäre
  * M - Memory/Accumulator schaltet den Accumulator auf 16-Bit wenn auf 0 gesetzt. Im Emulation Mode ist dieser auf 1 gezwungen
  * X - Index schaltet X und Y auf 16-Bit wenn auf 0 gesetzt. Wird im Emulation Mode auf 1 gesetzt und als B gehandelt.
  * B - Break beschreibt das X-Flag im Emulation mode. Es eig. immer 1 im Register und wird bei einem Interrupt als 0 gepusht, wenn der Interrupt nicht durch ein BRK ausgelöst wurde.
  * D - decimal, wenn auf 1, dann werden ADC und SBC im decimal mode berechnet ($20 - $04 = $16)
  * I - IRQ-Disable wenn auf true, werden keine Interrupts ausgeführt außer NMI
  * Z - Zero, wird bei null gestzt, zeigt ebenfalls gleichheit an. beq - branch if equal springt bei Z = 1
  * C - Carry wird als zusätzliches Bit für einige Operationen verwendet. C und XCE sind der einzige Weg des Prozessormodus anzupassen.

{{:statusregister.png?direct&800|}}

==== Accumulator (A) ====

Der Accumulator ist einer der Hauptregister mit denen gearbeitet wird.
Er wird hauptsächlich verwendet, wenn man Daten lesen schreiben und verrechnen möchte.
Er ist 16-Bit groß und kann im 8-Bit Modus verwendet werden (je nach P).
Im Gegensatz zu allen anderen "variablen" Register behält der Accumulator den Wert seines High-Byte bei.
So kann das High-Byte im 8-Bit modus als zusätzlicher Speicher verwendet werden.
Mit Hilfe der XBA instruktion kann so der Wert des High und des Low-Bytes getauscht werden.

je nach Situation hat der Accumulator drei Namen, A, B und C.
Mit C ist der Accumulator immer als 16-Bit Register bezeichnet.
Dementsprechend tauscht die Instruktion TCS immer die kompletten 16-Bit von A (C) nach S.
B beschreibt immer das High-Byte des Accumulators.
A beschreibt je nach Kontext entweder den Accumulator allgemein oder nur das LOW-Byte (z. B. in XBA - exchange B and A).
Einige Assembler nehmen diese Trennund nicht 100% und erlauben so auch z. B. die Operation TAS als Synonym für TCS.

==== X/Y Register (X/Y) ====

X und Y sind 2 Hilfsregister, welche zusammen mit dem Accumulator verwendet werden.
Sie sind 16-BIT groß und können je nach P auch als 8-Bit verwendet werden.
Werden Sie als 8-Bit verwendet ist das High-Byte immer 0

===== Prozessormodi =====

Der Prozesser hat 2 Modi, Emulation und Native.
Bei Start des Prozessors ist dieser immer im Emulation Mode und der PC zeigt auf den Reset-Vector.
Der Modus wird über die XCE-Instruktion gesetzt, wobei ein gesetztes C-Flag den Native-Mode aktiviert.
Im Emulation Mode ist der Prozessor kompatibel zum NES 6502, dementsprechend sind alle variablen Register im 8-BIT Modus.
Im Native-Mode können A, X, und Y je nach P als 16-Bit verwendet werden - S ist automatisch 16-BIT.
Die Interrupt-Handler sind unterschiedlich je nach Modus:
^ Adresse Emulation ^ Vector Emulation ^ Adresse Native ^ Vector Native ^
| $FFF4-5 | COP     | $FFE4-5 | COP |
| $FFF6-7 |         | $FFE6-7 | BRK |
| $FFF8-9 | ABORT   | $FFE8-9 | ABORT |
| $FFFA-B | NMI     | $FFEA-B | NMI |
| $FFFC-D | RESET   | $FFEC-D | RESET (ungenutzt) |
| $FFFE-F | IRQ/BRK | $FFEE-F | IRQ |

Da der Prozessor beim Startup immer im Emulation-Mode ist wird der Reset-Vector vom Native-Mode nicht genutzt.

===== Stack Operationen =====

Auf den Stack können einzelne Bytes oder Word gepusht werden.
Wenn immer ein Wert auf den Stack gepusht wird, wird der Stackpointer um 1 reduziert.
Wird ein Word gepusht, wird zuerst das High-Byte und anschließend das Low-Byte gepusht, sodass das Word im Speicher wieder in Little-Endian steht.
Wird ein Byte gepusht, wird zuerst der Wert im gespeichert und anschließend der Pointer dekrementiert.

===== Interrupts =====

Wenn ein Interrupt ausgelöst wird werden alle nötigen Register auf den Stack gepusht und je nach Modus zum Interrupthandler gesprungen.
Zusätzlich wird PBR auf 0 gesetzt, sodass sich ein Interrupthandler immer in der Bank 0 befindet.
Außerdem wird das IRQDisable-Flag auf 1 gesetzt (D auf 0), um weitere interrupts zu vermeiden.
Mithilfe von rti (0x40) wird zum vorherigen Zustand zurückgesprungen.
Folgende Werte werden in dieser Reihenfolge gepusht und bei rti umgedreht gepullt:
  * PBR (Native Mode)
  * PC (Short)
  * P

Ein Interrupt findet nicht statt, wenn das IRQ-Disable flag true ist.
Ausnahme hiervon ist der NMI, welcher nicht über P verhindert werden kann.

====== Operationen ======

====== Addressmodes ======

Der AddressMode zeigt an, welche Daten eine Operation nutzt, bzw. wie die Daten ermittelt werden.
Es gibt für das SNES folgende Addressmodes:
^ Addressmode ^ Schema ^ Bytes ^ Bank ^ Operationen ^
| absolute | a | 2 | DBR | ADC, AND, ASL, BIT, CMP, CPX, CPY, DEC, EOR, INC, JMP, JSR, LDA, LDX, LDY, LSR, ORA, ROL, ROR, SBC, STA, STX, STY, STZ, TRB, TSB  |
| absolute indexed indirect | (a,x) | 2 | PBR | JMP, JSR  |
| absolute indexed with x | a,x | 2 | DBR | ADC, AND, ASL, BIT, CMP, DEC, EOR, INC, LDA, LDY, LSR, ORA, ROL, ROR, SBC, STA, STZ  |
| absolute indexed with Y | a,y | 2 | DBR | ADC, AND, CMP, EOR, LDA, LDX, ORA, SBC, STA  |
| absolute indirect/absolute indirect long | (a)/(al) | 2/3 | 00/Param | JML, JMP |
| absolute long indexed with x | al,x | 3 | Caluculated | ADC, AND, CMP, EOR, LDA, ORA, SBC, STA |
| absolute long | al | 3 | Param | ADC, AND, CMP, EOR, JMP, JSR, LDA, ORA, SBC, STA |
| Accumulator | A | 0 | | ASL, DEA, DEC, INA, INC, LSR, ROL, ROR |
| Block Move | xyc | 2 | | MVN, MVP |
| direct indexed indirect | (d,x) | 1 | DBR | ADC, AND, CMP, EOR, LDA, ORA, SBC, STA  |
| direct indexed with X | d,x | 1 | 00 | ADC, AND, ASL, BIT, CMP, DEC, EOR, INC, LDA, LDY, LSR, ORA, ROL, ROR, SBC, STA, STY, STZ |
| direct indexed with Y | d,y | 1 | 00 | LDX, STX |
| direct indirect indexed | (d),y | 1 | calculated | ADC, AND, CMP, EOR, LDA, ORA, SBC, STA |
| direct indirect long indexed | [d],y | 1 | calculated | ADC, AND, CMP, EOR, LDA, ORA, SBC, STA |
| direct indirect long | [d] | 1 | loaded | ADC, AND, CMP, EOR, LDA, ORA, SBC, STA |
| direct indirect | (d) | 1 | DBR | ADC, AND, CMP, EOR, LDA, ORA, SBC, STA |
| direct | d | 1 | 00 | ADC, AND, ASL, BIT, CMP, CPX, CPY, DEC, EOR, INC, LDA, LDX, LDY, LSR, ORA, ROL, ROR, SBC, STA, STX, STY, STZ, TRB, TSB |
| immediate | # | 1/2 | | ADC, AND, BIT, CMP, CPX, CPY, EOR, LDA, LDX, LDY, ORA, REP, SBC, SEP |
| implied | i | 0 | | CLC, CLD, CLI, CLV, DEX, DEY, INX, INY, NOP, SEC, SED, SEI, STP, TAX, TAY, TCD, TCS, TDC, TSC, TSX, TXA, TXS, TXY, TYA, TYX, WAI, XBA, XCE |
| program counter relative long | rl | 2 | PBR | BRL |
| program counter relative | r | 1 | PBR | BCC, BCS, BEQ, BMI, BNE, BPL, BRA, BVC, BVS |
| Stack | s | 0 | | BRK, COP, PEA, PEI, PER, PHA, PHB, PHD, PHK, PHP, PHX, PHY, PLA, PLB, PLD, PLP, PLX, PLY, RTI, RTL, RTS |
| stack relative | d,s | 1 | 00 | ADC, AND, CMP, EOR, LDA, ORA, SBC, STA |
| stack relative indirect indexed | (d,s),y | 1 | Calculated | ADC, AND, CMP, EOR, LDA, ORA, SBC, STA |

Hierzu einige Regeln, welche man hieraus ableiten kann:
  * a (für absolute) heißt das die kommenden Bytes direkt genommen und ausgewertet werden 
  * d (für direct) im Vergleich zu a heißt immer, dass nur 1 Byte gebraucht wird und ein Register als 'Page' draufgerechnet wird. Dieses Register ist immer D ausßer bei (d,s),y wo es S ist.
  * eine Klammerung steht immer für einen Indirect-Zugriff. Das heißt es wird mit den Bytes eine Adresse aufgelöst, deren Inhalt wird als weitere Addresse verwendet, um den endgültigen Wert zu bestimmen.
  * Die eckigen Klammern [] wurden verwendet um bei direct zwischen der normalen () und der long [] Variante zu unterschieden. Hier hätte man auch alternative dl verwenden können anstelle einer neuen Klammerart
  * Ein Komma , bedeutet immer, dass das Register nach dem Komma auf den WErt aufgerechnet wird.
  * Die Darstellung zeigt den Ablauf der Auflösung z. B (a,x) heißt, es wird zuerst x aufgerechnet und dann die indirekte Auslösung, während (d),y umgekehrt arbeitet

===== Absolute Addresmodes =====

Bei Absolute AddressModes werden immer 2 oder 3 Bytes gelesen und weiterverarbeitet.
Dies sind generell die am einfachsten zu verstehenden Modi.
Die Varianten mit 3 Bytes werden dabei in der Regel mit dem Kürzel Long gekennzeichnet.

==== Absolute - a ====

Bei Absolute Addressing werden die kommenden 2 Bytes direkt als Addresse genommen.
Der DBR enthält dabei die Bank.

{{ ::addressmode_absolute.png?direct&400 |}}

Verwendende Operationen: ADC, AND, ASL, BIT, CMP, CPX, CPY, DEC, EOR, INC, JMP, JSR, LDA, LDX, LDY, LSR, ORA, ROL, ROR, SBC, STA, STX, STY, STZ, TRB, TSB

==== Absolute indexed indirect - (a,x) ====

Bei der Absolute indexed Indirect Adressierung werden die kommenden 2 Bytes als Basis genommen.
Auf diese Adresse wird dann das X-Register aufgerechnet.
Die Bank ist der PBR.

{{ ::addressmode_absoluteindexedindirect.png?direct&400 |}}

verwendende Operationen: JMP, JSR

==== Absolute Indexed with X - a,x ====
Bei Absolute Indexed with X-Addressing werden die kommenden 2 Byte als Basis genommen.
Auf diese wird das X-Register aufgerechnet.
Die Bank ist der DBR.

{{ ::addressmode_absoluteindexedwithx.png?direct&400 |}}

Verwendende Operationen: ADC, AND, ASL, BIT, CMP, DEC, EOR, INC, LDA, LDY, LSR, ORA, ROL, ROR, SBC, STA, STZ

==== Absolute Indexed with Y - a,y ====
Bei Absolute Indexed with Y-Addressing werden die kommenden 2 Byte als Basis genommen.
Auf diese wird das Y-Register aufgerechnet.
Die Bank ist der DBR.

{{ ::addressmode_absoluteindexedwithy.png?direct&400 |}}

Verwendende Operationen: ADC, AND, CMP, EOR, LDA, LDX, ORA, SBC, STA

==== Absolute indirect/Absolute indirect Long - (a)/(al) ====

Bei Absolute indirect-Addressing wird aus den nächsten 2 Byte die Basisaddresse gebildet.
Bei Absolute indirect Addressing ist die Bank 0, bei Absolute indirect long addressing wird sie durch das 3. kommende Byte bestimmt.

Je nach  Dokument wird nicht zwischen diesen beiden unterschieden.
Die Instruktion 6c entspricht einem JMP mit Absolute Indirect.
Die Instruktion dc entspricht einem JMP mit Absolute Indirect Long (in diesem Fall dir die Operation häufig auch JML genannt)

{{ ::addressmode_absoluteindirect.png?direct&400 |}}

verwendende Operationen: JML, JMP

==== Absolute long indexed with X - al,x ====

Bei Absolute Long indexed with X-Addressing wird eine effektive Address aus den kommenden 3 Bytes gebildet.
Auf dieses wird das X-Register aufgerechnet.
Durch diese Rechnung kann sich die Bank der Addresse verändern (Sie ist nicht fest definiert).

{{ ::addressmode_absolutelongindexedwithx.png?direct&400 |}}

verwendende Operationen: ADC, AND, CMP, EOR, LDA, ORA, SBC, STA

==== Absolute Long - al ====

Bei absolute Long-Addressing bildet sich die Addresse aus den kommenden 3 Parametern.

{{ ::addressmode_absolutelong.png?direct&400 |}}

verwendende Operationen: ADC, AND, CMP, EOR, JMP, JSR, LDA, ORA, SBC, STA

===== Direct addressmodes =====

Direct Addressmodes zeichnen sich dadurch aus, dass immer nur ein Byte als Parameter vorhanden ist und der Inhalt des D-Registers als Page verwendet wird.
Hierbei fällt auf, dass das D-Register 16-Bit groß ist und nicht 8.
Enthält das D-Register einen Wert != 0 im low-Byte so führt dies immer zu einem extra Cycle bei der Auswertung.

==== Direct indexed indirect - (d,x) ====

Bei Direct Indexed Indirect wird der Parameter mit D und X verrechnet.
Dies bildet die unteren 16-Bit einer effektiven Addresse mit der Bank 00 (bis hier genau wie bei (d,x)).
Aus dieser Addresse werden 2 Byte gelesen, welche mit dem DBR die Addresse bilden.

{{ ::addressmode_directindexedindirect.png?direct&400 |}}

verwendende Operationen: ADC, AND, CMP, EOR, LDA, ORA, SBC, STA

==== Direct indexed with X - (d,x) ====

Bei Direct Indexed With X werden die unteren 16-Bit gebildet, indem der Parameter mit D und X verrechnet wird.
Die Bank ist 00.

{{ ::addressmode_directindexedwithx.png?direct&400 |}}

verwendende Operationen: ADC, AND, ASL, BIT, CMP, DEC, EOR, INC, LDA, LDY, LSR, ORA, ROL, ROR, SBC, STA, STY, STZ

==== Direct indexed with Y - d,y ====

Bei Direct Indexed With Y werden die unteren 16-Bit gebildet, indem der Parameter mit D und Y verrechnet wird.
Die Bank ist 00.

{{ ::addressmode_directindexedwithy.png?direct&400 |}}

verwendende Operationen: LDX, STX

==== Direct indirect indexed - (d),y ====

Bei Direct Indirect Indexed-Addressing wird zuerst der Parameter mit D verrechnet um einen Pointer in der Bank 0 zu formen.
Von dieser Addresse werden anschließend 16 Bit geladen mit dem DBR als Bank.
Hierauf wird dann Y addiert.
Dadurch kann sich die Bank ändern (Sie ist nicht genau definiert).

Dieser Modus ist identisch mit [d],y mit der Ausnahme, dass DBR als Bank genutzt wird.

{{ ::addressmode_directindirectindexed.png?direct&400 |}}

verwendende Operationen: ADC, AND, CMP, EOR, LDA, ORA, SBC, STA

==== Direct Indirect Long Indexed - [d],y ====

Bei Direct Indirect Long Indexed-Addressing wird zuerst der Parameter mit D verrechnet um einen Pointer in der Bank 0 zu formen.
Von dieser Addresse werden anschließend eine effektive Addresse geladen (3 Byte) (Bis hierhin identisch mit [d]).
Hierauf wird zuletzt Y addiert.
Dadurch kann sich die Bank ändern (Sie ist nicht genau definiert).

Dieser Modus ist identisch mit (d),y mit der Ausnahme, dass eine effektive Addresse geladen wird udn nicht nur 2 Byte.

{{ ::addressmode_directindirectlongindexed.png?direct&400 |}}

verwendende Operationen: ADC, AND, CMP, EOR, LDA, ORA, SBC, STA

==== Direct indirect Long - [d] ====

Bei Direct indirect long-indexing wird ein Pointer in Bank 0 gebildet, indem der Parameter mit D verrechnet wird.
Aus dieser Address wird eine neue Addresse geladen (3 Byte).

{{ ::addressmode_directindirectlong.png?direct&400 |}}

verwendende Operationen: ADC, AND, CMP, EOR, LDA, ORA, SBC, STA

==== Direct indirect - (d) ====

Bei der Direct Indirect-Addressierung wird der Parameter mit D verrechnet und als Basis für einen Point in der Pank 0 genutzt.
Aus dieser Addresse werden 126 Bit geladen, welche mit dem DBR als Bank die endgültige Addresse bilden.

{{ ::addressmode_directindirect.png?direct&400 |}}

verwendende Operationen: ADC, AND, CMP, EOR, LDA, ORA, SBC, STA

==== Direct - d ====

Bei Direct-Addressing bildet D zusammen mit dem Parameter die Addresse in der Bank 0.

{{ ::addressmode_direct.png?direct&400 |}}

verwendende Operationen: ADC, AND, ASL, BIT, CMP, CPX, CPY, DEC, EOR, INC, LDA, LDX, LDY, LSR, ORA, ROL, ROR, SBC, STA, STX, STY, STZ, TRB, TSB

===== Andere Addressmodes =====

==== Accumulator - A ====

Der Parameter ist der Wert des A-Registers.

verwendende Operationen: ASL, DEA, DEC, INA, INC, LSR, ROL, ROR

==== Block Move - xyc ====

Block Move-Addressing ist ein spezieller Addressmode, welche mit den MVN und MVP Operationen verwendet wird.
Das erste folgende Byte wird dabei in den DBR kopiert und dient als Zielbank mit Y als Addresse.
Das zweite folgende Byte dient als Quellbank und wir mit X als Addresse verwendet.

{{ ::addressmode_blockmove.png?direct&400 |}}

verwendende Operationen: MVN, MVP

==== Immediate - # ====

Bei Immediate werden die kommenden Bytes direkt als Wert an die Operation weitergegeben ohne Verrechnung.
Je nach Instruktion werden hierfür entweder die nächsten 2 oder nur das nächste 1 Byte geladen.
Für P-Operationen (REP, SEP) wird immer nur 1 Byte geladen.
Operationen auf X oder Y (CPX, CPY, LDX, LDY) brauchen 1 Byte, wenn das jeweilige Register im 8-Bit-Modus ist, ansonsten 2 Byte.
Alle anderen Operationen beziehen sich auf A und brauchen entsprechend der größe von A.

verwendende Operationen: ADC, AND, BIT, CMP, CPX, CPY, EOR, LDA, LDX, LDY, ORA, REP, SBC, SEP

==== Implied - i ====

Mit implied sind alle Operationen gekennzeichnet, welche keine weiteren Parameter brauchen, da sich alle benötigten Daten aus der Operation selbst ergeben.

verwendende Operationen: CLC, CLD, CLI, CLV, DEX, DEY, INX, INY, NOP, SEC, SED, SEI, STP, TAX, TAY, TCD, TCS, TDC, TSC, TSX, TXA, TXS, TXY, TYA, TYX, WAI, XBA, XCE

==== Program counter relative long - rl ====

Bei der Program counter relative long-Addressierung werden die nächsten 2 Byte geladen und als vorzeichenbelastete Zahl gewertet.
Diese Zahl ist ein Offset, welcher auf dern PC gerechnet wird, welcher bereits auf die nächte Instruktion zeigt.

verwendende Operationen: BRL

==== Program counter relative - r ====

Bei der Program counter relative long-Addressierung werden das nächste 1 Byte geladen und als vorzeichenbelastete Zahl gewertet.
Diese Zahl ist ein Offset, welcher auf dern PC gerechnet wird, welcher bereits auf die nächte Instruktion zeigt.

verwendende Operationen: BCC, BCS, BEQ, BMI, BNE, BPL, BRA, BVC, BVS

==== Stack - s ====

Mit Stack werden alle Operationen gekennzeichnet, welche auf dem stack operieren.

verwendende Operationen: BRK, COP, PEA, PEI, PER, PHA, PHB, PHD, PHK, PHP, PHX, PHY, PLA, PLB, PLD, PLP, PLX, PLY, RTI, RTL, RTS

==== Stack relative - d,s ====

Stack relative-Addressing ist eine Sonderform des Direct-Addressing, bei dem S anstelle von D verwendet wird.
Der Parameter (1 Byte) wird mit S addiert und die Bank ist 00.

{{ ::addressmode_stackrelative.png?direct&400 |}}

verwendende Operationen: ADC, AND, CMP, EOR, LDA, ORA, SBC, STA

==== Stack relative indirect indexed - (d,s),y ====

S wird mit dem nächsten Byte verrechnet, um einen Pointer in Bank 00 zu formen.
Hier werden 16 Bit ausgelesen, welche die Basisadresse in Bank DBR bilden.
Diese Addresse wird abschließend mit Y verrechnet.
Dadurch kann sich die Bank ändern (Die Bank ist nicht genau definiert)

{{ ::addressmode_stackrelativeindirectindexed.png?direct&400 |}}

verwendende Operationen: ADC, AND, CMP, EOR, LDA, ORA, SBC, STA

====== Instructions ======